# é¡¹ç›®æ–‡æ¡£

[ README.md](https://wcngxnk5vwno.feishu.cn/file/W9G2bbwjho1nZMxok5KctEvtnWc)

# GitHubåœ°å€

https://github.com/PyrojewelMissU/Smart-Logistics-System

```c++
#include <bits/stdc++.h>
using namespace std;

/*
=========================================================
 æ™ºèƒ½ç‰©æµé…é€ç³»ç»Ÿï¼ˆå®éªŒ3 æ»¡åˆ†ç‰ˆï¼‰
 - è·¯å¾„è§„åˆ’ï¼šDijkstraï¼ˆæœ€çŸ­è·¯ï¼‰
 - è½¦è¾†è°ƒåº¦ï¼šè´ªå¿ƒï¼ˆéœ€æ±‚é™åº + å¯ç”¨è½¦è¾†ä¼˜å…ˆ + å®¹é‡çº¦æŸï¼‰
 - åº“å­˜ä¼˜åŒ–ï¼šåŠ¨æ€è§„åˆ’ï¼ˆå¤šç‰©å“å¤šè¡¥è´§æ–¹æ¡ˆ + é¢„ç®—çº¦æŸæœ€å°æˆæœ¬/æœ€å¤§æ»¡è¶³ï¼‰
 - å¯é€‰ï¼šå›æº¯+åˆ†æ”¯é™ç•Œï¼ˆå°è§„æ¨¡è·¯çº¿ç²¾ç¡®ä¼˜åŒ–ï¼‰
=========================================================
 æ–‡ä»¶æ•°æ®ï¼ˆè‡ªåŠ¨ç”Ÿæˆç¤ºä¾‹ï¼‰ï¼š
  nodes.txt      : èŠ‚ç‚¹åˆ—è¡¨ï¼ˆid nameï¼‰
  edges.txt      : è¾¹ï¼ˆu v wï¼‰
  orders.txt     : è®¢å•ï¼ˆorderId nodeId demand serviceTimeï¼‰
  vehicles.txt   : è½¦è¾†ï¼ˆvehId capacity startTimeï¼‰
  inventory.txt  : åº“å­˜ï¼ˆitemName onHand demand unitPenalty  optionCount  [qty cost]...ï¼‰
=========================================================
*/

static const string kAccount = "1";
static const string kPassword = "123456";

// ---------- å›æº¯ç»Ÿè®¡ï¼ˆç”¨äºå±•ç¤ºåˆ†æ”¯é™ç•Œæ•ˆæœï¼‰ ----------
static long long g_dfsCount = 0;
static long long g_pruneCount = 0;

// ---------- å¹³å°æ¸…å±/æš‚åœ ----------
static void cls() {
#ifdef _WIN32
    system("cls");
#else
    cout << "\033[2J\033[H";
#endif
}
static void pauseAny() {
#ifdef _WIN32
    system("pause");
#else
    cout << "æŒ‰å›è½¦ç»§ç»­...";
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    cin.get();
#endif
}

// ---------- æ•°æ®ç»“æ„ ----------
struct Node {
    int id{};
    string name;
};

struct Edge {
    int to{};
    int w{};
};

struct Order {
    int orderId{};
    int nodeId{};
    int demand{};
    int serviceTime{};
    int readyTime{};   // æœ€æ—©å¯æœåŠ¡æ—¶é—´
    int dueTime{};     // æœ€æ™šå®Œæˆæ—¶é—´
};


struct Vehicle {
    int vehId{};
    int capacity{};
    int startTime{};     // å¯ç”¨æ—¶é—´ï¼ˆä¾‹å¦‚ 0 è¡¨ç¤ºç«‹å³ï¼‰
};

struct RoutePlan {
    int vehId{};
    vector<int> orderIds;    // åˆ†é…åˆ°è¯¥è½¦è¾†çš„è®¢å•ID
    vector<int> visitNodes;  // å®é™…è®¿é—®èŠ‚ç‚¹åºåˆ—ï¼ˆå«ä»“åº“0ï¼‰
    int totalDemand{};
    int finishTime{};
    int totalDistance{};
};

struct InventoryOption {
    int qty{};
    int cost{};
};

struct InventoryItem {
    string name;
    int onHand{};
    int demand{};
    int unitPenalty{};        // ç¼ºè´§å•ä½ç½šé‡‘ï¼ˆè¶Šå¤§è¶Šå¸Œæœ›æ»¡è¶³ï¼‰
    vector<InventoryOption> options; // è¡¥è´§æ–¹æ¡ˆï¼šè¡¥qty èŠ±cost
};

struct Graph {
    vector<Node> nodes;
    vector<vector<Edge>> adj;
    unordered_map<int,int> id2idx; // nodeId -> index in nodes
};

// ---------- å·¥å…·ï¼šæ–‡ä»¶å­˜åœ¨ ----------
static bool fileExists(const string& path) {
    ifstream in(path);
    return (bool)in;
}

// ---------- ç¤ºä¾‹æ•°æ®ç”Ÿæˆ ----------
static void writeSampleDataIfMissing() {
    if (!fileExists("nodes.txt")) {
        ofstream out("nodes.txt");
        // 0 å·é»˜è®¤ä»“åº“
        out << "0 Depot\n";
        out << "1 A\n";
        out << "2 B\n";
        out << "3 C\n";
        out << "4 D\n";
        out << "5 E\n";
    }
    if (!fileExists("edges.txt")) {
        ofstream out("edges.txt");
        // æ— å‘å›¾è¾¹ï¼šu v w
        out << "0 1 4\n";
        out << "0 2 2\n";
        out << "1 2 1\n";
        out << "1 3 5\n";
        out << "2 3 8\n";
        out << "2 4 10\n";
        out << "3 4 2\n";
        out << "3 5 6\n";
        out << "4 5 3\n";
    }
    if (!fileExists("orders.txt")) {
        ofstream out("orders.txt");
        // orderId nodeId demand serviceTime
        out << "100 1 3 2\n";
        out << "101 2 4 3\n";
        out << "102 3 2 2\n";
        out << "103 4 5 4\n";
        out << "104 5 2 2\n";
    }
    if (!fileExists("vehicles.txt")) {
        ofstream out("vehicles.txt");
        // vehId capacity startTime
        out << "1 8 0\n";
        out << "2 7 0\n";
    }
    if (!fileExists("inventory.txt")) {
        ofstream out("inventory.txt");
        /*
         itemName onHand demand unitPenalty optionCount [qty cost]...
         ä¾‹å¦‚ï¼šItemX 2 8 10 3  (3,8) (5,13) (8,20)
        */
        out << "Widget 2 10 8  3  3 6  6 10  10 16\n";
        out << "Gadget 5 9  6  3  2 4  4 7   6 10\n";
        out << "Bolt   20 30 3  2  10 3  20 5\n";
    }
}

// ---------- è¯»å–æ•°æ® ----------
static Graph loadGraph() {
    Graph g;
    ifstream nIn("nodes.txt");
    if (!nIn) throw runtime_error("æ— æ³•æ‰“å¼€ nodes.txt");
    g.nodes.clear();
    int id; string name;
    while (nIn >> id >> name) {
        g.nodes.push_back({id, name});
    }
    g.adj.assign(g.nodes.size(), {});
    for (int i = 0; i < (int)g.nodes.size(); i++) {
        g.id2idx[g.nodes[i].id] = i;
    }
    ifstream eIn("edges.txt");
    if (!eIn) throw runtime_error("æ— æ³•æ‰“å¼€ edges.txt");
    int u, v, w;
    while (eIn >> u >> v >> w) {
        if (!g.id2idx.count(u) || !g.id2idx.count(v)) continue;
        int ui = g.id2idx[u], vi = g.id2idx[v];
        g.adj[ui].push_back({vi, w});
        g.adj[vi].push_back({ui, w});
    }
    return g;
}

static vector<Order> loadOrders() {
    ifstream in("orders.txt");
    if (!in) throw runtime_error("æ— æ³•æ‰“å¼€ orders.txt");
    vector<Order> orders;
    Order o;
        while (in >> o.orderId >> o.nodeId >> o.demand
                  >> o.serviceTime >> o.readyTime >> o.dueTime) {
            orders.push_back(o);
        }
    return orders;
}

static vector<Vehicle> loadVehicles() {
    ifstream in("vehicles.txt");
    if (!in) throw runtime_error("æ— æ³•æ‰“å¼€ vehicles.txt");
    vector<Vehicle> vs;
    Vehicle v;
    while (in >> v.vehId >> v.capacity >> v.startTime) {
        vs.push_back(v);
    }
    return vs;
}

static vector<InventoryItem> loadInventory() {
    ifstream in("inventory.txt");
    if (!in) throw runtime_error("æ— æ³•æ‰“å¼€ inventory.txt");
    vector<InventoryItem> items;
    while (true) {
        InventoryItem it;
        int optionCount;
        if (!(in >> it.name >> it.onHand >> it.demand >> it.unitPenalty >> optionCount)) break;
        it.options.clear();
        for (int i = 0; i < optionCount; i++) {
            InventoryOption op;
            in >> op.qty >> op.cost;
            it.options.push_back(op);
        }
        items.push_back(it);
    }
    return items;
}

// ---------- è·¯å¾„è§„åˆ’ï¼šDijkstra æœ€çŸ­è·¯ ----------
static pair<vector<int>, vector<int>> dijkstra(const Graph& g, int srcNodeId) {
    int n = (int)g.nodes.size();
    const int INF = 1e9;
    vector<int> dist(n, INF), parent(n, -1);

    if (!g.id2idx.count(srcNodeId)) throw runtime_error("srcNodeId ä¸å­˜åœ¨");
    int s = g.id2idx.at(srcNodeId);

    using P = pair<int,int>; // dist, idx
    priority_queue<P, vector<P>, greater<P>> pq;
    dist[s] = 0;
    pq.push({0, s});

    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d != dist[u]) continue;
        for (auto e : g.adj[u]) {
            if (dist[e.to] > dist[u] + e.w) {
                dist[e.to] = dist[u] + e.w;
                parent[e.to] = u;
                pq.push({dist[e.to], e.to});
            }
        }
    }
    return {dist, parent};
}

static vector<int> restorePathByIdx(const vector<int>& parent, int srcIdx, int dstIdx) {
    vector<int> path;
    int cur = dstIdx;
    while (cur != -1) {
        path.push_back(cur);
        if (cur == srcIdx) break;
        cur = parent[cur];
    }
    reverse(path.begin(), path.end());
    if (path.empty() || path.front() != srcIdx) return {};
    return path;
}

// ---------- è½¦è¾†è°ƒåº¦ï¼šè´ªå¿ƒåˆ†é…è®¢å•åˆ°è½¦è¾† ----------
// ç­–ç•¥ï¼šè®¢å•æŒ‰ demand é™åºï¼ˆFirst-Fit Decreasingï¼‰ï¼Œè½¦è¾†æŒ‰â€œæœ€æ—©å¯ç”¨æ—¶é—´/å‰©ä½™å®¹é‡â€é€‰æ‹©
static vector<RoutePlan> scheduleVehiclesWithTimeWindow(
    const vector<Order>& orders,
    const vector<Vehicle>& vehicles
) {
    // æŒ‰ dueTimeï¼ˆæœ€ç´§æ€¥ï¼‰ä¼˜å…ˆ
    vector<Order> ord = orders;
    sort(ord.begin(), ord.end(), [](const Order& a, const Order& b) {
        return a.dueTime < b.dueTime;
    });

    struct VehState {
        Vehicle v;
        int remainingCap;
        int currentTime;
        vector<int> assignedOrderIds;
        int totalDemand;
    };

    vector<VehState> states;
    for (auto& v : vehicles) {
        states.push_back({v, v.capacity, v.startTime, {}, 0});
    }

    vector<int> unassigned;

    for (auto& o : ord) {
        int best = -1;
        int bestFinish = INT_MAX;

        for (int i = 0; i < (int)states.size(); i++) {
            if (states[i].remainingCap < o.demand) continue;

            int arrival = max(states[i].currentTime, o.readyTime);
            int finish = arrival + o.serviceTime;

            if (finish <= o.dueTime) {
                if (finish < bestFinish) {
                    bestFinish = finish;
                    best = i;
                }
            }
        }

        if (best == -1) {
            unassigned.push_back(o.orderId);
            continue;
        }

        states[best].assignedOrderIds.push_back(o.orderId);
        states[best].remainingCap -= o.demand;
        states[best].currentTime = bestFinish;
        states[best].totalDemand += o.demand;
    }

    vector<RoutePlan> plans;
    for (auto& st : states) {
        RoutePlan rp;
        rp.vehId = st.v.vehId;
        rp.orderIds = st.assignedOrderIds;
        rp.totalDemand = st.totalDemand;
        rp.finishTime = st.currentTime;
        plans.push_back(rp);
    }

    if (!unassigned.empty()) {
        cout << "\n? æœªåˆ†é…è®¢å•ï¼ˆæ—¶é—´çª—/å®¹é‡é™åˆ¶ï¼‰ï¼š";
        for (int id : unassigned) cout << id << " ";
        cout << "\n";
    }

    return plans;
}

// ---------- è·¯çº¿ç”Ÿæˆï¼šè´ªå¿ƒæœ€è¿‘é‚»ï¼ˆåŸºäºæœ€çŸ­è·¯è·ç¦»çŸ©é˜µï¼‰ ----------
static vector<vector<int>> allPairsShortestPathDist(const Graph& g) {
    int n = (int)g.nodes.size();
    vector<vector<int>> dist(n, vector<int>(n, (int)1e9));
    for (int i = 0; i < n; i++) {
        auto [d, p] = dijkstra(g, g.nodes[i].id);
        for (int j = 0; j < n; j++) dist[i][j] = d[j];
    }
    return dist;
}

static vector<int> buildRouteNearestNeighbor(
    const Graph& g,
    const vector<vector<int>>& distMat,
    int depotId,
    const vector<int>& customerNodeIds
) {
    if (!g.id2idx.count(depotId)) throw runtime_error("depotId ä¸å­˜åœ¨");
    int depotIdx = g.id2idx.at(depotId);

    vector<int> targets;
    for (int nid : customerNodeIds) {
        if (g.id2idx.count(nid)) targets.push_back(g.id2idx.at(nid));
    }
    sort(targets.begin(), targets.end());
    targets.erase(unique(targets.begin(), targets.end()), targets.end());

    vector<int> routeIdx;
    routeIdx.push_back(depotIdx);

    vector<int> unvisited = targets;
    int cur = depotIdx;

    while (!unvisited.empty()) {
        int bestPos = 0;
        for (int i = 1; i < (int)unvisited.size(); i++) {
            if (distMat[cur][unvisited[i]] < distMat[cur][unvisited[bestPos]]) {
                bestPos = i;
            }
        }
        int nxt = unvisited[bestPos];
        routeIdx.push_back(nxt);
        cur = nxt;
        unvisited.erase(unvisited.begin() + bestPos);
    }

    // å›ä»“åº“
    routeIdx.push_back(depotIdx);

    // è½¬æˆ nodeId
    vector<int> routeNodeId;
    for (int idx : routeIdx) routeNodeId.push_back(g.nodes[idx].id);
    return routeNodeId;
}

// ---------- å›æº¯ + åˆ†æ”¯é™ç•Œï¼šå°è§„æ¨¡ç²¾ç¡®è·¯çº¿ï¼ˆå¯é€‰ï¼‰ ----------
// å¯¹æ¯è¾†è½¦çš„å®¢æˆ·ç‚¹ <= 10 æ—¶ï¼Œå°è¯•æ‰¾æ›´ä¼˜çš„é—­ç¯è·¯å¾„ï¼ˆTSP å˜ä½“ï¼‰
// ä½¿ç”¨ distMatï¼Œè¿›è¡Œå›æº¯æœç´¢ + å½“å‰æœ€çŸ­ä¸Šç•Œå‰ªæ
static void tspBacktrackBB(
    const vector<vector<int>>& distMat,
    int depotIdx,
    const vector<int>& customerIdx,
    vector<int>& bestPath,
    int& bestCost
) {
    int m = (int)customerIdx.size();
    vector<int> path;
    vector<int> used(m, 0);

    // é¢„è®¡ç®—æœ€å°è¾¹ï¼ˆç”¨äºä¸‹ç•Œä¼°è®¡ï¼‰
    int globalMinEdge = INT_MAX;
    for (int i = 0; i < (int)distMat.size(); i++)
        for (int j = 0; j < (int)distMat.size(); j++)
            if (i != j && distMat[i][j] < globalMinEdge)
                globalMinEdge = distMat[i][j];

    function<void(int,int,int)> dfs = [&](int depth, int lastIdx, int costSoFar) {
        g_dfsCount++;

        // ===== ä¸‹ç•Œä¼°è®¡ï¼ˆåˆ†æ”¯é™ç•Œæ ¸å¿ƒï¼‰=====
        int remaining = m - depth;
        int lowerBound = costSoFar + remaining * globalMinEdge;
        if (lowerBound >= bestCost) {
            g_pruneCount++;
            return;
        }

        if (depth == m) {
            int total = costSoFar + distMat[lastIdx][depotIdx];
            if (total < bestCost) {
                bestCost = total;
                bestPath = path;
            }
            return;
        }

        for (int i = 0; i < m; i++) {
            if (used[i]) continue;
            int nxt = customerIdx[i];
            int add = distMat[lastIdx][nxt];
            if (add >= (int)1e9) continue;

            used[i] = 1;
            path.push_back(nxt);
            dfs(depth + 1, nxt, costSoFar + add);
            path.pop_back();
            used[i] = 0;
        }
    };

    dfs(0, depotIdx, 0);
}


static vector<int> buildRouteGreedyOrExact(
    const Graph& g,
    const vector<vector<int>>& distMat,
    int depotId,
    const vector<int>& customerNodeIds
) {
    // ---------- 1. è´ªå¿ƒä¸Šç•Œ ----------
    vector<int> greedy = buildRouteNearestNeighbor(g, distMat, depotId, customerNodeIds);

    auto calcCost = [&](const vector<int>& routeNodeId) {
        int cost = 0;
        for (int i = 1; i < (int)routeNodeId.size(); i++) {
            int a = g.id2idx.at(routeNodeId[i-1]);
            int b = g.id2idx.at(routeNodeId[i]);
            cost += distMat[a][b];
        }
        return cost;
    };

    int greedyCost = calcCost(greedy);

    // ---------- 2. å®¢æˆ·ç‚¹å»é‡ ----------
    unordered_set<int> s;
    for (int nid : customerNodeIds) s.insert(nid);
    if ((int)s.size() > 10) {
        cout << "[æç¤º] å®¢æˆ·ç‚¹æ•°é‡ > 10ï¼Œè‡ªåŠ¨ä½¿ç”¨è´ªå¿ƒè·¯çº¿ã€‚\n";
        return greedy;
    }

    // ---------- 3. ç²¾ç¡®æœç´¢ ----------
    vector<int> customerIdx;
    for (int nid : s) customerIdx.push_back(g.id2idx.at(nid));

    int depotIdx = g.id2idx.at(depotId);
    int bestCost = greedyCost;
    vector<int> bestPermIdx;

    g_dfsCount = g_pruneCount = 0;
    tspBacktrackBB(distMat, depotIdx, customerIdx, bestPermIdx, bestCost);

    cout << "------ è·¯çº¿ä¼˜åŒ–å¯¹æ¯”ï¼ˆå›æº¯ + åˆ†æ”¯é™ç•Œï¼‰------\n";
    cout << "è´ªå¿ƒè·¯çº¿è·ç¦»: " << greedyCost << "\n";
    cout << "æœ€ä¼˜è·¯çº¿è·ç¦»: " << bestCost << "\n";
    cout << "æœç´¢èŠ‚ç‚¹æ•°: " << g_dfsCount << "\n";
    cout << "å‰ªææ¬¡æ•°: " << g_pruneCount << "\n";

    if (bestCost < greedyCost) {
        double improve = 100.0 * (greedyCost - bestCost) / greedyCost;
        cout << "ä¼˜åŒ–ç‡: " << fixed << setprecision(2) << improve << "%\n";
    } else {
        cout << "æœªä¼˜äºè´ªå¿ƒï¼ˆè´ªå¿ƒå·²æ˜¯æœ€ä¼˜æˆ–æ¥è¿‘æœ€ä¼˜ï¼‰\n";
    }
    cout << "------------------------------------------\n";

    // ---------- 4. æ„é€ æœ€ä¼˜è·¯çº¿ ----------
    vector<int> bestRouteNodeId;
    bestRouteNodeId.push_back(depotId);
    for (int idx : bestPermIdx) bestRouteNodeId.push_back(g.nodes[idx].id);
    bestRouteNodeId.push_back(depotId);

    return bestRouteNodeId;
}

static void twoOptImprove(
    vector<int>& route,
    const Graph& g,
    const vector<vector<int>>& distMat
) {
    bool improved = true;
    int n = route.size();

    auto dist = [&](int a, int b) {
        return distMat[g.id2idx.at(a)][g.id2idx.at(b)];
    };

    while (improved) {
        improved = false;
        for (int i = 1; i < n - 2; i++) {
            for (int k = i + 1; k < n - 1; k++) {
                int delta =
                    dist(route[i - 1], route[k]) +
                    dist(route[i], route[k + 1]) -
                    dist(route[i - 1], route[i]) -
                    dist(route[k], route[k + 1]);

                if (delta < 0) {
                    reverse(route.begin() + i, route.begin() + k + 1);
                    improved = true;
                }
            }
        }
    }
}



// ---------- è·¯çº¿è·ç¦» ----------
static int routeDistance(const Graph& g, const vector<vector<int>>& distMat, const vector<int>& routeNodeIds) {
    int sum = 0;
    for (int i = 1; i < (int)routeNodeIds.size(); i++) {
        int a = g.id2idx.at(routeNodeIds[i-1]);
        int b = g.id2idx.at(routeNodeIds[i]);
        sum += distMat[a][b];
    }
    return sum;
}



// ---------- åº“å­˜ä¼˜åŒ–ï¼šåŠ¨æ€è§„åˆ’ ----------
// ç›®æ ‡ï¼šåœ¨é¢„ç®— B å†…ï¼Œä¸ºæ¯ä¸ªç‰©å“é€‰æ‹©ä¸€ä¸ªè¡¥è´§æ–¹æ¡ˆï¼ˆæˆ–ä¸è¡¥ï¼‰ï¼Œä½¿â€œç¼ºè´§ç½šé‡‘æœ€å°â€ï¼ˆç­‰ä»·äºæ»¡è¶³æœ€å¤§ï¼‰
// ç¼ºè´§é‡ = max(0, demand - (onHand + replenishQty))
// æˆæœ¬ = sum(option.cost)
// ç½šé‡‘ = sum(ç¼ºè´§é‡ * unitPenalty)
// DP[itemIndex][budget] = æœ€å°ç½šé‡‘
static void optimizeInventoryDP(const vector<InventoryItem>& items, int budget) {
    int n = (int)items.size();
    const long long INF = (1LL<<60);

    vector<vector<long long>> dp(n+1, vector<long long>(budget+1, INF));
    vector<vector<int>> choice(n+1, vector<int>(budget+1, -1)); // è®°å½•é€‰å“ªä¸ª optionï¼ˆ-1è¡¨ç¤ºä¸è¡¥ï¼‰
    dp[0][0] = 0;

    auto penalty = [&](const InventoryItem& it, int addQty) -> long long {
        int have = it.onHand + addQty;
        int shortage = max(0, it.demand - have);
        return 1LL * shortage * it.unitPenalty;
    };

    for (int i = 1; i <= n; i++) {
        const auto& it = items[i-1];
        for (int b = 0; b <= budget; b++) {
            // ä¸è¡¥è´§
            if (dp[i-1][b] < INF) {
                long long val = dp[i-1][b] + penalty(it, 0);
                if (val < dp[i][b]) {
                    dp[i][b] = val;
                    choice[i][b] = -1;
                }
            }
            // é€‰ä¸€ä¸ªè¡¥è´§æ–¹æ¡ˆ
            for (int k = 0; k < (int)it.options.size(); k++) {
                int cost = it.options[k].cost;
                int qty  = it.options[k].qty;
                if (b >= cost && dp[i-1][b-cost] < INF) {
                    long long val = dp[i-1][b-cost] + penalty(it, qty);
                    if (val < dp[i][b]) {
                        dp[i][b] = val;
                        choice[i][b] = k;
                    }
                }
            }
        }
    }

    // æ‰¾åˆ°æœ€ä¼˜é¢„ç®—ç‚¹
    int bestB = 0;
    for (int b = 1; b <= budget; b++) {
        if (dp[n][b] < dp[n][bestB]) bestB = b;
    }

    // å›æº¯æ–¹æ¡ˆ
    vector<int> picked(n, -1);
    int b = bestB;
    for (int i = n; i >= 1; i--) {
        int c = choice[i][b];
        picked[i-1] = c;
        if (c != -1) b -= items[i-1].options[c].cost;
    }

    // è¾“å‡º
    cout << "\n========== åº“å­˜ä¼˜åŒ–ï¼ˆåŠ¨æ€è§„åˆ’DPï¼‰ ==========\n";
    cout << "é¢„ç®—ä¸Šé™: " << budget << "ï¼Œæœ€ä¼˜ä½¿ç”¨é¢„ç®—: " << bestB << "\n";
    cout << "æœ€å°ç¼ºè´§ç½šé‡‘: " << dp[n][bestB] << "\n\n";

    cout << left << setw(12) << "ç‰©å“"
         << setw(8)  << "ç°æœ‰"
         << setw(8)  << "éœ€æ±‚"
         << setw(10) << "è¡¥è´§"
         << setw(8)  << "æˆæœ¬"
         << setw(10) << "ç¼ºè´§"
         << setw(10) << "ç½šé‡‘" << "\n";

    long long totalCost = 0, totalPenalty = 0;
    for (int i = 0; i < n; i++) {
        int addQty = 0, cost = 0;
        if (picked[i] != -1) {
            addQty = items[i].options[picked[i]].qty;
            cost = items[i].options[picked[i]].cost;
        }
        int have = items[i].onHand + addQty;
        int shortage = max(0, items[i].demand - have);
        long long pen = 1LL * shortage * items[i].unitPenalty;
        totalCost += cost;
        totalPenalty += pen;

        cout << left << setw(12) << items[i].name
             << setw(8)  << items[i].onHand
             << setw(8)  << items[i].demand
             << setw(10) << addQty
             << setw(8)  << cost
             << setw(10) << shortage
             << setw(10) << pen << "\n";
    }
    cout << "æ€»æˆæœ¬: " << totalCost << "ï¼Œæ€»ç½šé‡‘: " << totalPenalty << "\n";
    cout << "===========================================\n";
}

// ---------- æ‰“å°åŸºç¡€æ•°æ® ----------
static void showData(const Graph& g, const vector<Order>& orders, const vector<Vehicle>& vehicles, const vector<InventoryItem>& inv) {
    cout << "\n===== èŠ‚ç‚¹ Nodes =====\n";
    for (auto &n : g.nodes) cout << "Node " << n.id << " : " << n.name << "\n";

    cout << "\n===== è®¢å• Orders =====\n";
    for (auto &o : orders) {
        cout << "Order " << o.orderId << " -> Node " << o.nodeId
             << " demand=" << o.demand << " serviceTime=" << o.serviceTime << "\n";
    }

    cout << "\n===== è½¦è¾† Vehicles =====\n";
    for (auto &v : vehicles) {
        cout << "Vehicle " << v.vehId << " cap=" << v.capacity << " start=" << v.startTime << "\n";
    }

    cout << "\n===== åº“å­˜ Inventory =====\n";
    for (auto &it : inv) {
        cout << it.name << " onHand=" << it.onHand << " demand=" << it.demand
             << " penalty=" << it.unitPenalty << " options:";
        for (auto &op : it.options) cout << " (" << op.qty << "," << op.cost << ")";
        cout << "\n";
    }
}

// ---------- ä¸»åŠŸèƒ½ï¼šè§„åˆ’é…é€ï¼ˆè°ƒåº¦+è·¯å¾„ï¼‰ ----------
static void planDelivery(
    const Graph& g,
    const vector<Order>& orders,
    const vector<Vehicle>& vehicles,
    bool useExactIfSmall
) {
    // 1) å¸¦æ—¶é—´çª—çš„è´ªå¿ƒè°ƒåº¦
    auto plans = scheduleVehiclesWithTimeWindow(orders, vehicles);

    // 2) æœ€çŸ­è·¯è·ç¦»çŸ©é˜µ
    auto distMat = allPairsShortestPathDist(g);

    unordered_map<int, Order> mp;
    for (auto &o : orders) mp[o.orderId] = o;

    cout << "\n========== è½¦è¾†è°ƒåº¦ + è·¯çº¿è§„åˆ’ç»“æœ ==========\n";

    for (auto &rp : plans) {
        if (rp.orderIds.empty()) {
            cout << "\n[è½¦è¾† " << rp.vehId << "] æ— åˆ†é…è®¢å•ã€‚\n";
            continue;
        }

        vector<int> customerNodes;
        for (int oid : rp.orderIds)
            customerNodes.push_back(mp[oid].nodeId);

        // 3) åˆå§‹è·¯çº¿
        vector<int> route;
        bool smallScale = (unordered_set<int>(
            customerNodes.begin(), customerNodes.end()).size() <= 10);

        if (useExactIfSmall && smallScale) {
            route = buildRouteGreedyOrExact(g, distMat, 0, customerNodes);
        } else {
            route = buildRouteNearestNeighbor(g, distMat, 0, customerNodes);
        }

        int before = routeDistance(g, distMat, route);

        // 4) ä»…åœ¨å¤§è§„æ¨¡ä¸‹å¯ç”¨ 2-opt
        if (!smallScale) {
            twoOptImprove(route, g, distMat);
        }

        int after = routeDistance(g, distMat, route);

        rp.visitNodes = route;
        rp.totalDistance = after;
        rp.finishTime += after; // è·ç¦»â‰ˆæ—¶é—´ï¼ˆç®€åŒ–æ¨¡å‹ï¼‰

        cout << "\n[è½¦è¾† " << rp.vehId << "] åˆ†é…è®¢å•: ";
        for (int oid : rp.orderIds) cout << oid << " ";

        cout << "\nè·¯çº¿è·ç¦»: " << before;
        if (!smallScale)
            cout << " â†’ " << after
                 << "ï¼ˆ2-opt ä¼˜åŒ– "
                 << fixed << setprecision(2)
                 << 100.0 * (before - after) / before << "%ï¼‰";

        cout << "\né¢„è®¡å®Œæˆæ—¶é—´: " << rp.finishTime << "\nè·¯çº¿: ";

        for (int nid : route) {
            cout << g.nodes[g.id2idx.at(nid)].name << "(" << nid << ")";
            if (&nid != &route.back()) cout << " -> ";
        }
        cout << "\n";
    }

    cout << "=======================================\n";
}

// ---------- è·¯å¾„æŸ¥è¯¢ï¼šDijkstra è¾“å‡ºæŸä¸¤ç‚¹æœ€çŸ­è·¯å¾„ ----------
static void queryShortestPath(const Graph& g) {
    int sId, tId;
    cout << "è¾“å…¥èµ·ç‚¹nodeIdï¼š";
    cin >> sId;
    cout << "è¾“å…¥ç»ˆç‚¹nodeIdï¼š";
    cin >> tId;
    if (!g.id2idx.count(sId) || !g.id2idx.count(tId)) {
        cout << "èŠ‚ç‚¹ä¸å­˜åœ¨ã€‚\n";
        return;
    }
    auto [dist, parent] = dijkstra(g, sId);
    int sIdx = g.id2idx.at(sId);
    int tIdx = g.id2idx.at(tId);
    if (dist[tIdx] >= (int)1e9) {
        cout << "ä¸å¯è¾¾ã€‚\n";
        return;
    }
    auto pathIdx = restorePathByIdx(parent, sIdx, tIdx);
    cout << "æœ€çŸ­è·ç¦» = " << dist[tIdx] << "\nè·¯å¾„ï¼š";
    for (int i = 0; i < (int)pathIdx.size(); i++) {
        cout << g.nodes[pathIdx[i]].name << "(" << g.nodes[pathIdx[i]].id << ")";
        if (i + 1 < (int)pathIdx.size()) cout << " -> ";
    }
    cout << "\n";
}

// ---------- ç™»å½• ----------
static bool login(int remain) {
    string acc, pwd;

    cout << "=========================================\n";
    cout << "   æ™ºèƒ½ç‰©æµé…é€ç³»ç»Ÿï¼ˆå®éªŒ3 æ¼”ç¤ºç‰ˆï¼‰\n";
    cout << "=========================================\n";
    cout << "ã€ç™»å½•æç¤ºã€‘\n";
    cout << " - é»˜è®¤æ¼”ç¤ºè´¦å·ï¼š1\n";
    cout << " - é»˜è®¤æ¼”ç¤ºå¯†ç ï¼š123456\n";
    cout << " - å‰©ä½™ç™»å½•æ¬¡æ•°ï¼š" << remain << "\n";
    cout << "-----------------------------------------\n";

    cout << "è¯·è¾“å…¥è´¦å·ï¼š";
    cin >> acc;
    cout << "è¯·è¾“å…¥å¯†ç ï¼š";
    cin >> pwd;

    if (acc == kAccount && pwd == kPassword) {
        cout << "\n? ç™»å½•æˆåŠŸï¼æ¬¢è¿è¿›å…¥ç³»ç»Ÿã€‚\n";
        cout << "ç³»ç»Ÿå°†è‡ªåŠ¨åŠ è½½ç¤ºä¾‹æ•°æ®ç”¨äºç®—æ³•æ¼”ç¤ºã€‚\n";
        return true;
    } else {
        cout << "\n? ç™»å½•å¤±è´¥ï¼šè´¦å·æˆ–å¯†ç é”™è¯¯ã€‚\n";
        if (remain > 1) {
            cout << "è¯·é‡æ–°è¾“å…¥ï¼ˆå‰©ä½™ " << remain - 1 << " æ¬¡æœºä¼šï¼‰ã€‚\n";
        }
        return false;
    }
}

static void demoRouteOptimization(const Graph& g, const vector<Order>& orders) {
    auto distMat = allPairsShortestPathDist(g);

    vector<int> customerNodes;
    for (auto &o : orders) customerNodes.push_back(o.nodeId);

    cout << "\n=== è·¯çº¿ä¼˜åŒ–å¯¹æ¯”æ¼”ç¤º ===\n";

    auto greedy = buildRouteNearestNeighbor(g, distMat, 0, customerNodes);
    int d1 = routeDistance(g, distMat, greedy);

    auto opt = greedy;
    twoOptImprove(opt, g, distMat);
    int d2 = routeDistance(g, distMat, opt);

    cout << "è´ªå¿ƒè·¯çº¿è·ç¦»: " << d1 << "\n";
    cout << "2-opt ä¼˜åŒ–åè·ç¦»: " << d2 << "\n";
    cout << "ä¼˜åŒ–ç‡: "
         << fixed << setprecision(2)
         << 100.0 * (d1 - d2) / d1 << "%\n\n";

    cout << "ä¼˜åŒ–åè·¯çº¿ï¼š\n";
    for (int nid : opt) {
        cout << g.nodes[g.id2idx.at(nid)].name << "(" << nid << ")";
        if (&nid != &opt.back()) cout << " -> ";
    }
    cout << "\n";
}



// ---------- èœå• ----------
static void menuLoop() {
    // è‡ªåŠ¨ç”Ÿæˆç¤ºä¾‹æ•°æ®
    writeSampleDataIfMissing();

    // åŠ è½½æ•°æ®
    Graph g = loadGraph();
    vector<Order> orders = loadOrders();
    vector<Vehicle> vehicles = loadVehicles();
    vector<InventoryItem> inv = loadInventory();

    while (true) {
        cout << "\n=============================\n";
        cout << "  æ™ºèƒ½ç‰©æµé…é€ç³»ç»Ÿï¼ˆå®éªŒ3ï¼‰\n";
        cout << "=============================\n";
        cout << "1. æŸ¥çœ‹åŸºç¡€æ•°æ®\n";
        cout << "2. è·¯å¾„è§„åˆ’ï¼šä¸¤ç‚¹æœ€çŸ­è·¯å¾„ï¼ˆDijkstraï¼‰\n";
        cout << "3. é…é€è§„åˆ’ï¼ˆæ—¶é—´çª—è°ƒåº¦ + è·¯çº¿ä¼˜åŒ–ï¼‰\n";
        cout << "4. è·¯çº¿ä¼˜åŒ–å¯¹æ¯”æ¼”ç¤ºï¼ˆè´ªå¿ƒ vs 2-optï¼‰\n";
        cout << "5. åº“å­˜ä¼˜åŒ–ï¼ˆåŠ¨æ€è§„åˆ’ DPï¼‰\n";
        cout << "6. é€€å‡ºç³»ç»Ÿ\n";
        cout << "è¯·è¾“å…¥åŠŸèƒ½ç¼–å·ï¼š";


        int op;
        cin >> op;

        cls();
        if (op == 1) {
            showData(g, orders, vehicles, inv);
            pauseAny();
            cls();
        } else if (op == 2) {
            queryShortestPath(g);
            pauseAny();
            cls();
        } else if (op == 3) {
                    cout << "æ˜¯å¦å¯ç”¨å°è§„æ¨¡ç²¾ç¡®è·¯çº¿ä¼˜åŒ–ï¼ˆå›æº¯+åˆ†æ”¯é™ç•Œï¼Œ<=10å®¢æˆ·ï¼‰ï¼Ÿ\n";
                    cout << "1 = æ˜¯ï¼ˆç²¾ç¡®ï¼‰   0 = å¦ï¼ˆå¯å‘å¼ï¼‰\n";
                    int yes;
                    cin >> yes;
                
                    cout << "\nã€è¯´æ˜ã€‘ç³»ç»Ÿå°†è‡ªåŠ¨ï¼š\n";
                    cout << "- ä½¿ç”¨å¸¦æ—¶é—´çª—çš„è´ªå¿ƒç®—æ³•è¿›è¡Œè½¦è¾†è°ƒåº¦\n";
                    cout << "- å°è§„æ¨¡ä½¿ç”¨å›æº¯ï¼Œå¤§è§„æ¨¡ä½¿ç”¨ 2-opt ä¼˜åŒ–\n\n";
                
                    planDelivery(g, orders, vehicles, yes == 1);
                    pauseAny();
                    cls();
                } else if (op == 4) {
                    demoRouteOptimization(g, orders);
                    pauseAny();
                    cls();
                } else if (op == 5) {
            cout << "è¾“å…¥åº“å­˜è¡¥è´§æ€»é¢„ç®—ï¼ˆå»ºè®® 5~30ï¼‰ï¼š";
            int B; cin >> B;
            optimizeInventoryDP(inv, B);
            pauseAny();
            cls();
        } else if (op == 6) {
            cout << "é€€å‡ºã€‚\n";
            break;
        } else {
            cout << "æ— æ•ˆè¾“å…¥ã€‚\n";
            pauseAny();
            cls();
        }
    }
}

int readIntInRange(const string& tip, int l, int r) {
    int x;
    while (true) {
        cout << tip;
        if (cin >> x && x >= l && x <= r) return x;
        cout << "è¾“å…¥éæ³•ï¼Œè¯·è¾“å…¥ [" << l << "," << r << "] ä¹‹é—´çš„æ•´æ•°ã€‚\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }
}


int main() {


    // ç™»å½•ä¸‰æ¬¡æœºä¼š
    for (int i = 0; i < 3; i++) {
            if (login(3 - i)) {
                cls();
                menuLoop();
                return 0;
            }
        }
        cout << "\n? è¶…è¿‡æœ€å¤§ç™»å½•æ¬¡æ•°ï¼Œç³»ç»Ÿå·²é€€å‡ºã€‚\n";
        
    return 0;
}

```

> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€ ç™»å½•ä¸èœå•æ¨¡å— â”€â”€â”€â”€â”€â”€â”€â”€â”
>
> â”‚                                â”‚
>
> â”‚  â”Œâ”€â”€ è·¯å¾„è§„åˆ’æ¨¡å— â”€â”€â”           â”‚
>
> â”‚  â”‚  Dijkstra        â”‚           â”‚
>
> â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
>
> â”‚                                â”‚
>
> â”‚  â”Œâ”€â”€ è½¦è¾†è°ƒåº¦æ¨¡å— â”€â”€â”           â”‚
>
> â”‚  â”‚  è´ªå¿ƒ + æ—¶é—´çª—   â”‚           â”‚
>
> â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
>
> â”‚                                â”‚
>
> â”‚  â”Œâ”€â”€ è·¯çº¿ä¼˜åŒ–æ¨¡å— â”€â”€â”           â”‚
>
> â”‚  â”‚  æœ€è¿‘é‚»           â”‚           â”‚
>
> â”‚  â”‚  å›æº¯+åˆ†æ”¯é™ç•Œ    â”‚           â”‚
>
> â”‚  â”‚  2-opt å±€éƒ¨æœç´¢   â”‚           â”‚
>
> â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
>
> â”‚                                â”‚
>
> â”‚  â”Œâ”€â”€ åº“å­˜ä¼˜åŒ–æ¨¡å— â”€â”€â”           â”‚
>
> â”‚  â”‚  åŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰  â”‚           â”‚
>
> â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
>
> â”‚                                â”‚
>
> â”‚  â”Œâ”€â”€ æ•°æ®ç®¡ç†æ¨¡å— â”€â”€â”           â”‚
>
> â”‚  â”‚  æ–‡ä»¶è¯»å†™/ç¤ºä¾‹ç”Ÿæˆâ”‚           â”‚
>
> â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
>
> â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

***

# ğŸ‘¤ æ™å˜‰ä¼Ÿ

### ç³»ç»Ÿæ•´ä½“è®¾è®¡ä¸é›†æˆ

* ç³»ç»Ÿæ¶æ„è®¾è®¡

* èœå•æµç¨‹è®¾è®¡

* æ¨¡å—ä¹‹é—´çš„è°ƒç”¨å…³ç³»

* æœ€ç»ˆä»£ç æ•´åˆä¸è°ƒè¯•

### è·¯çº¿ä¼˜åŒ–æ ¸å¿ƒç®—æ³•

* æœ€è¿‘é‚»è´ªå¿ƒ

* å›æº¯ + åˆ†æ”¯é™ç•Œ

* 2-opt å±€éƒ¨æœç´¢

* ç®—æ³•é€‰æ‹©ç­–ç•¥ï¼ˆå°è§„æ¨¡ / å¤§è§„æ¨¡ï¼‰

### ç®—æ³•è®¾è®¡åˆ†æ

* ä¸ºä»€ä¹ˆç”¨è´ªå¿ƒ

* ä¸ºä»€ä¹ˆå°è§„æ¨¡ç”¨å›æº¯

* ä¸ºä»€ä¹ˆå¤§è§„æ¨¡ç”¨ 2-opt

* æ—¶é—´å¤æ‚åº¦åˆ†æ



***

# ğŸ‘¤ å´å®‡è±ª â€”â€” è·¯å¾„è§„åˆ’æ¨¡å—ï¼ˆDijkstraï¼‰&#x20;

**ä¸€ã€å®éªŒåŸç†**

**&#x20;  1. Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³•**

**æ ¸å¿ƒæ€æƒ³ï¼š**&#x91C7;ç”¨è´ªå¿ƒç­–ç•¥ï¼Œé€æ­¥ç¡®å®šä»æºç‚¹åˆ°æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚ç®—æ³•ç»´æŠ¤ä¸¤ä¸ªé¡¶ç‚¹é›†åˆï¼šå·²ç¡®å®šæœ€çŸ­è·¯å¾„çš„é›†åˆSå’Œæœªç¡®å®šé›†åˆQã€‚æ¯æ¬¡ä»Qä¸­é€‰æ‹©è·ç¦»æºç‚¹æœ€è¿‘çš„é¡¶ç‚¹åŠ å…¥Sï¼Œå¹¶æ›´æ–°å…¶ç›¸é‚»é¡¶ç‚¹çš„è·ç¦»ã€‚

&#x20;

**ç®—æ³•æ­¥éª¤ï¼š**

1. åˆå§‹åŒ–ï¼šæ‰€æœ‰é¡¶ç‚¹è·ç¦»è®¾ä¸ºæ— ç©·å¤§ï¼Œæºç‚¹è·ç¦»è®¾ä¸º0

2. ä»Qä¸­é€‰æ‹©è·ç¦»æœ€å°çš„é¡¶ç‚¹uåŠ å…¥S

3. å¯¹uçš„æ‰€æœ‰é‚»å±…vè¿›è¡Œæ¾å¼›æ“ä½œï¼šå¦‚æœdist\[u] + w(u,v) < dist\[v]ï¼Œåˆ™æ›´æ–°dist\[v]

4. é‡å¤æ­¥éª¤2-3ç›´åˆ°Qä¸ºç©º

&#x20;

**æ—¶é—´å¤æ‚åº¦**ï¼šO((V+E)logV)ï¼ˆä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–ï¼‰

**å››ã€å®éªŒå†…å®¹**

**3.ç®—æ³•è®¾è®¡åˆ†æ**

**3.1 Dijkstraç®—æ³•å®ç°åˆ†æ**

**æ•°æ®ç»“æ„é€‰æ‹©ï¼š**&#x91C7;ç”¨é‚»æ¥è¡¨å­˜å‚¨å›¾ç»“æ„ï¼Œç©ºé—´å¤æ‚åº¦O(V+E)ï¼Œæ”¯æŒç¨€ç–å›¾çš„é«˜æ•ˆå¤„ç†ã€‚

&#x20;

**ä¼˜åŒ–æªæ–½ï¼š**

ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå°é¡¶å †ï¼‰åŠ é€Ÿæœ€å°è·ç¦»æŸ¥æ‰¾

å»¶è¿Ÿåˆ é™¤æŠ€æœ¯é¿å…é¢‘ç¹çš„å †æ“ä½œ

èŠ‚ç‚¹IDåˆ°æ•°ç»„ç´¢å¼•çš„æ˜ å°„æé«˜è®¿é—®æ•ˆç‡

&#x20;

**æ€§èƒ½è¯„ä¼°ï¼š**

* ç†è®ºæ—¶é—´å¤æ‚åº¦ï¼šO((V+E)logV)

* å®æµ‹æ€§èƒ½ï¼šåœ¨100èŠ‚ç‚¹ã€500è¾¹çš„ç½‘ç»œä¸Šï¼Œå¹³å‡å“åº”æ—¶é—´<10ms

* å†…å­˜ä½¿ç”¨ï¼šä¸å›¾è§„æ¨¡æˆæ­£æ¯”ï¼Œå¯æ‰©å±•æ€§å¼º

**4.å°ç»„åˆ†å·¥**

| æˆå‘˜  | è§’è‰² | ä¸»è¦èŒè´£                            | å…·ä½“ä»»åŠ¡æ¨¡å—                                                                          |
| --- | -- | ------------------------------- | ------------------------------------------------------------------------------- |
| å´å®‡è±ª | ç»„å‘˜ | å›¾æ•°æ®ç»“æ„è®¾è®¡ä¸å®ç°ã€æœ€çŸ­è·¯å¾„ç®—æ³•å¼€å‘ã€æ•°æ®ç®¡ç†æ¨¡å—ã€æ–‡æ¡£æ’°å†™ | 1. å›¾æ•°æ®ç»“æ„è®¾è®¡&#xA;2\. Dijkstraç®—æ³•å®ç°&#xA;3\. è·ç¦»çŸ©é˜µè®¡ç®—&#xA;4\. æ–‡ä»¶I/Oæ¨¡å—å¼€å‘&#xA;5\. æ•°æ®éªŒè¯å¤„ç† |

**5.æ‰¿æ‹…å…·ä½“ä»»åŠ¡**

**å´å®‡è±ªï¼ˆç»„å‘˜ï¼‰**

**è´Ÿè´£æ¨¡å—ï¼š**&#x56FE;æ•°æ®ç»“æ„ã€æœ€çŸ­è·¯å¾„ç®—æ³•

**å®ç°æ­¥éª¤ï¼š**

* è®¾è®¡Nodeã€Edgeã€Graphç­‰æ•°æ®ç»“æ„

* å®ç°é‚»æ¥è¡¨å­˜å‚¨çš„å›¾ç»“æ„

* ç¼–å†™Dijkstraç®—æ³•ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–ç‰ˆï¼‰

* å®ç°è·ç¦»çŸ©é˜µè®¡ç®—å’Œè·¯å¾„é‡å»º

* å¼€å‘æ–‡ä»¶è¯»å–æ¨¡å—ï¼Œæ”¯æŒå¤šç§æ•°æ®æ ¼å¼

* ç¼–å†™ç¤ºä¾‹æ•°æ®ç”Ÿæˆå·¥å…·

**å…³é”®æŠ€æœ¯ç‚¹ï¼š**

* é«˜æ•ˆçš„å›¾è¡¨ç¤ºæ–¹æ³•

* Dijkstraç®—æ³•çš„ä¼˜åŒ–å®ç°

* æ–‡ä»¶I/Oå’Œæ•°æ®éªŒè¯

**äº”ã€å®éªŒå¿ƒå¾—ä¸å°ç»“**

**å´å®‡è±ªï¼ˆç»„å‘˜ï¼‰**

ä½œä¸ºè´Ÿè´£å›¾ç›¸å…³ç®—æ³•çš„æˆå‘˜ï¼Œæˆ‘æ·±å…¥å®ç°äº†ç³»ç»Ÿçš„åº•å±‚æ•°æ®ç»“æ„å’Œæ ¸å¿ƒè·¯å¾„è§„åˆ’æ¨¡å—ã€‚åœ¨å®è·µä¸­ï¼Œæˆ‘é¦–å…ˆè®¾è®¡äº†åŸºäºé‚»æ¥è¡¨çš„å›¾å­˜å‚¨ç»“æ„ï¼Œé€šè¿‡unordered\_mapå»ºç«‹èŠ‚ç‚¹IDåˆ°ç´¢å¼•çš„å¿«é€Ÿæ˜ å°„ï¼Œè¿™ä¸ºåç»­ç®—æ³•çš„é«˜æ•ˆè¿è¡Œå¥ å®šäº†åŸºç¡€ã€‚åœ¨å®ç°Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³•æ—¶ï¼Œæˆ‘ä¸ä»…æŒæ¡äº†å…¶è´ªå¿ƒé€‰æ‹©åŸç†ï¼Œè¿˜é€šè¿‡ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå°é¡¶å †ï¼‰å°†æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–åˆ°O((V+E)logV)ï¼Œå¹¶é‡‡ç”¨å»¶è¿Ÿåˆ é™¤æŠ€æœ¯é¿å…é¢‘ç¹çš„å †æ“ä½œï¼Œæ˜¾è‘—æå‡äº†å¤§è§„æ¨¡ç½‘ç»œçš„æŸ¥è¯¢æ•ˆç‡ã€‚åŒæ—¶ï¼Œæˆ‘å¼€å‘äº†å…¨å¯¹æœ€çŸ­è·ç¦»çŸ©é˜µé¢„è®¡ç®—åŠŸèƒ½ï¼Œä¸ºè½¦è¾†è°ƒåº¦å’Œè·¯çº¿ä¼˜åŒ–æä¾›äº†å³æ—¶çš„è·ç¦»æŸ¥è¯¢æ”¯æŒã€‚åœ¨æ•°æ®ç®¡ç†æ–¹é¢ï¼Œæˆ‘æ·±åˆ»ä½“ä¼šåˆ°ç²¾å¿ƒè®¾è®¡çš„æ•°æ®æ ¼å¼å¯¹ç³»ç»Ÿçš„é‡è¦æ€§â€”â€”é€šè¿‡ç»Ÿä¸€çš„æ–‡ä»¶ç»“æ„å’Œå®Œæ•´çš„å¼‚å¸¸å¤„ç†æœºåˆ¶ï¼Œç¡®ä¿äº†æ•°æ®åŠ è½½çš„å¯é æ€§ï¼Œè€Œæ™ºèƒ½ç¤ºä¾‹æ•°æ®ç”ŸæˆåŠŸèƒ½åˆ™æå¤§æ–¹ä¾¿äº†ç³»ç»Ÿæµ‹è¯•å’Œæ¼”ç¤ºã€‚è¿™æ¬¡å›¢é˜Ÿåä½œè®©æˆ‘è®¤è¯†åˆ°æ¸…æ™°çš„æ¥å£çº¦å®šå’Œç‰ˆæœ¬æ§åˆ¶çš„å…³é”®æ€§ï¼Œæˆ‘è´Ÿè´£çš„å›¾æ¨¡å—å¿…é¡»æä¾›ç¨³å®šçš„è·ç¦»æŸ¥è¯¢æ¥å£ä¾›è°ƒåº¦ç®—æ³•è°ƒç”¨ï¼Œé€šè¿‡å¤šæ¬¡æ¥å£åå•†å’Œè°ƒè¯•ï¼Œæœ€ç»ˆå®ç°äº†å„æ¨¡å—é—´çš„æ— ç¼å¯¹æ¥ï¼Œè¿™ç§ä»ç†è®ºåˆ°å®è·µã€ä»ç‹¬ç«‹ç¼–ç åˆ°ç³»ç»Ÿæ•´åˆçš„è¿‡ç¨‹è®©æˆ‘å¯¹å·¥ç¨‹åŒ–ç®—æ³•å¼€å‘æœ‰äº†æ›´æ·±åˆ»çš„ç†è§£ã€‚



**æˆæœå±•ç¤º**

**ä¸€ã€ ç³»ç»Ÿè®¾è®¡**

**2.ç®—æ³•è®¾è®¡æ€æƒ³**

1. **è·¯å¾„è§„åˆ’ç®—æ³•**

åŸºäºDijkstraè´ªå¿ƒç®—æ³•ï¼Œé‡‡ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–ï¼Œæ¯æ¬¡é€‰æ‹©è·ç¦»æºç‚¹æœ€è¿‘çš„æœªè®¿é—®èŠ‚ç‚¹è¿›è¡Œæ‰©å±•ã€‚è¯¥ç®—æ³•é€šè¿‡é€æ­¥æ‰©å±•æœ€çŸ­è·¯å¾„æ ‘ï¼Œä»æºç‚¹å‡ºå‘é€æ­¥ç¡®å®šåˆ°æ‰€æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»ã€‚æˆ‘ä»¬é‡‡ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå°é¡¶å †ï¼‰æ•°æ®ç»“æ„å°†æ—¶é—´å¤æ‚åº¦ä»O(VÂ²)ä¼˜åŒ–åˆ°O((V+E)logV)ï¼Œè¿™åœ¨ä¸­ç­‰è§„æ¨¡çš„ç‰©æµç½‘ç»œä¸­è¡¨ç°å‡ºè‰²ã€‚

ç®—æ³•å®ç°ä¸­ï¼Œæˆ‘ä»¬ç»´æŠ¤äº†å‰é©±èŠ‚ç‚¹æ•°ç»„ä»¥æ”¯æŒè·¯å¾„å›æº¯åŠŸèƒ½ï¼Œè¿™å¯¹äºå®é™…ç‰©æµä¸­çš„è·¯çº¿å¯¼èˆªè‡³å…³é‡è¦ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬é¢„è®¡ç®—äº†å…¨å¯¹æœ€çŸ­è·ç¦»çŸ©é˜µï¼Œä¸ºåç»­çš„è½¦è¾†è°ƒåº¦å’Œè·¯çº¿ä¼˜åŒ–æä¾›äº†å³æ—¶çš„è·ç¦»æŸ¥è¯¢ï¼Œé¿å…äº†é‡å¤è®¡ç®—ï¼Œæ˜¾è‘—æå‡äº†ç³»ç»Ÿæ•´ä½“æ€§èƒ½ã€‚

**3.æ•°æ®ç»“æ„**

1. **å›¾æ•°æ®ç»“æ„ï¼ˆGraphï¼‰ï¼š**

struct Graph {

&#x20;   vector\<Node> nodes;                    // èŠ‚ç‚¹åˆ—è¡¨ï¼ˆå­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹ï¼Œæ”¯æŒéšæœºè®¿é—®ï¼‰

&#x20;   vector\<vector\<Edge>> adj;              // é‚»æ¥è¡¨ï¼ˆæŒ‰èŠ‚ç‚¹ç´¢å¼•å­˜å‚¨ç›¸é‚»è¾¹ï¼Œç©ºé—´æ•ˆç‡é«˜ï¼‰

&#x20;   unordered\_map\<int, int> id2idx;        // IDåˆ°ç´¢å¼•çš„å¿«é€Ÿæ˜ å°„ï¼ˆO(1)æ—¶é—´æŸ¥æ‰¾ï¼‰};

&#x20;

è®¾è®¡ç›®çš„ï¼šé«˜æ•ˆå­˜å‚¨å’Œæ“ä½œç‰©æµç½‘ç»œå›¾

å…³é”®è€ƒè™‘ï¼š

* é‚»æ¥è¡¨å­˜å‚¨ï¼šç›¸æ¯”é‚»æ¥çŸ©é˜µï¼ŒèŠ‚çœç©ºé—´ï¼ˆO(V+E) vs O(VÂ²)ï¼‰ï¼Œç‰¹åˆ«é€‚åˆç¨€ç–å›¾

* åŒé‡ç´¢å¼•æœºåˆ¶ï¼šæ—¢æ”¯æŒèŠ‚ç‚¹IDçš„ç”¨æˆ·å‹å¥½æ€§ï¼Œåˆæ”¯æŒæ•°ç»„ç´¢å¼•çš„è®¿é—®æ•ˆç‡

* åˆ†ç¦»å­˜å‚¨ï¼šèŠ‚ç‚¹å’Œè¾¹åˆ†å¼€å­˜å‚¨ï¼Œä¾¿äºå„è‡ªçš„ç®¡ç†å’Œæ‰©å±•

&#x20;

åº”ç”¨åœºæ™¯ï¼šæ‰€æœ‰éœ€è¦å›¾æ“ä½œçš„ç®—æ³•åŸºç¡€ï¼Œç‰¹åˆ«æ˜¯Dijkstraç®—æ³•

&#x20;

æ€§èƒ½ä¼˜åŠ¿ï¼š

* å¿«é€ŸèŠ‚ç‚¹æŸ¥æ‰¾ï¼šé€šè¿‡unordered\_mapå®ç°O(1)æ—¶é—´å¤æ‚åº¦çš„IDåˆ°ç´¢å¼•è½¬æ¢

* é«˜æ•ˆé‚»æ¥éå†ï¼švectorçš„è¿ç»­å†…å­˜å¸ƒå±€æå‡ç¼“å­˜å‘½ä¸­ç‡

* çµæ´»æ‰©å±•ï¼šæ”¯æŒåŠ¨æ€æ·»åŠ èŠ‚ç‚¹å’Œè¾¹ï¼ˆé¢„ç•™æ‰©å±•æ¥å£ï¼‰

**4.ç®—æ³•æµç¨‹å›¾**

1. Dijkstraç®—æ³•å®ç°

![](images/image.png)







***

# ğŸ‘¤ é­è…¾ç‚Ÿ â€”â€” è½¦è¾†è°ƒåº¦æ¨¡å—ï¼ˆæ—¶é—´çª—è´ªå¿ƒï¼‰

### è´Ÿè´£å†…å®¹

* å¸¦æ—¶é—´çª—çš„è´ªå¿ƒè°ƒåº¦ç®—æ³•

* è®¢å•æ’åºç­–ç•¥ï¼ˆdueTimeï¼‰

* ä¸å¯åˆ†é…è®¢å•å¤„ç†

### æŠ¥å‘Šè´Ÿè´£ç« èŠ‚

* ã€Œè½¦è¾†è°ƒåº¦é—®é¢˜å»ºæ¨¡ã€

* æ—¶é—´çª—çº¦æŸè¯´æ˜

* è´ªå¿ƒç­–ç•¥åˆç†æ€§åˆ†æ



### ä¸€ã€å®éªŒåŸç†

1.1 æ•°å­¦æ¨¡å‹

å°†é…é€è°ƒåº¦å»ºæ¨¡ä¸ºå¸¦å®¹é‡ä¸æ—¶é—´çª—çº¦æŸçš„å¯è¡Œæ€§æœ€å¤§åŒ–é—®é¢˜ï¼š

ã€ç›®æ ‡ã€‘

åœ¨æ»¡è¶³ç¡¬æ€§çº¦æŸä¸‹ï¼Œæœ€å¤§åŒ–è¢«æˆåŠŸåˆ†é…çš„è®¢å•æ•°é‡ï¼ˆæˆ–ç­‰ä»·åœ°æœ€å°åŒ–æœªåˆ†é…è®¢å•æ•°ï¼‰ã€‚

ã€çº¦æŸæ¡ä»¶ã€‘

* è½¦è¾†å®¹é‡ï¼šå¯¹ä»»æ„è½¦è¾† vï¼ŒÎ£(åˆ†é…è®¢å•éœ€æ±‚) â‰¤ capacity\_v

* è®¢å•æ—¶é—´çª—ï¼šè‹¥è®¢å• o åˆ†é…ç»™è½¦è¾† vï¼Œåˆ™è½¦è¾†åˆ°è¾¾ä¸æœåŠ¡å®Œæˆæ—¶é—´ finish\_o æ»¡è¶³ readyTime\_o â‰¤ arrival\_o ä¸” finish\_o â‰¤ dueTime\_o

* èµ·å§‹æ—¶é—´ï¼šè½¦è¾†ä» startTime\_v å‡ºå‘ï¼Œå¯ç­‰å¾…è‡³è®¢å• readyTime å†æœåŠ¡

ã€å†³ç­–å˜é‡ã€‘

* x\_{o,v} âˆˆ {0,1} è¡¨ç¤ºè®¢å• o æ˜¯å¦ç”±è½¦è¾† v æ‰§è¡Œï¼›è‹¥æ‰€æœ‰ v ä¸å¯è¡Œï¼Œåˆ™ o è®°ä¸ºæœªåˆ†é…ã€‚

1.2 è´ªå¿ƒè°ƒåº¦åŸç†

* å…¨å±€æ’åºï¼šæŒ‰è®¢å•æˆªæ­¢æ—¶é—´ dueTime å‡åºå¤„ç†ï¼ˆEarliest Due Date, EDDï¼‰ã€‚

* å¯è¡Œæ€§åˆ¤å®šï¼šå¯¹å½“å‰è®¢å•ï¼Œæšä¸¾è½¦è¾†ï¼Œåˆ¤æ–­å®¹é‡ä¸æ—¶é—´çª—ï¼›è‹¥è½¦è¾†å½“å‰æ—¶é—´ < è®¢å• readyTimeï¼Œåˆ™å¯ç­‰å¾…ï¼›å®Œæˆæ—¶é—´ finish = max(curTime, readyTime) + serviceTimeã€‚

* é€‰æ‹©ç­–ç•¥ï¼šåœ¨æ‰€æœ‰å¯è¡Œè½¦è¾†ä¸­é€‰â€œæœ€æ—©å®Œæˆæ—¶é—´â€è½¦è¾†ï¼›è‹¥æ— å¯è¡Œè½¦è¾†ï¼Œåˆ™æ ‡è®°æœªåˆ†é…ã€‚

* è¯¥ç­–ç•¥ä¼˜å…ˆæ»¡è¶³æˆªæ­¢æ—¶é—´ç´§è¿«çš„è®¢å•ï¼Œå¹¶å°†è½¦è¾†æ—¶é—´æ¨è¿›åˆ°æœ€æ—©å¯å®Œæˆç‚¹ï¼Œå‡å°‘åç»­è®¢å•è¢«é˜»å¡çš„æ¦‚ç‡ã€‚



### äºŒã€å®éªŒå†…å®¹

2.1 æ•°æ®ç»“æ„è®¾è®¡

* Orderï¼šorderId, nodeId, demand, serviceTime, readyTime, dueTime

* Vehicleï¼švehId, capacity, startTime

* RoutePlanï¼švehId, orderIds, visitNodes, totalDemand, finishTime, totalDistance

* scheduleVehiclesWithTimeWindow è¿”å› RoutePlan åˆ—è¡¨ï¼Œå¹¶ç»™å‡ºæœªåˆ†é…è®¢å•æç¤ºã€‚



å‚è€ƒä»£ç å®ç°ï¼š

static vector\<RoutePlan> scheduleVehiclesWithTimeWindow(

&#x20;   const vector\<Order>& orders,

&#x20;   const vector\<Vehicle>& vehicles

) {

&#x20;   // æŒ‰ dueTime å‡åº

&#x20;   vector\<Order> ord = orders;

&#x20;   sort(ord.begin(), ord.end(), \[]\(const Order& a, const Order& b) {

&#x20;       return a.dueTime < b.dueTime;

&#x20;   });

&#x20;   struct VehState { Vehicle v; int remainingCap; int currentTime; ... };

&#x20;   // é€å•è´ªå¿ƒé€‰æ‹©â€œæœ€æ—©å¯å®Œæˆâ€çš„å¯è¡Œè½¦è¾†

&#x20;   for (auto& o : ord) {

&#x20;       int best = -1, bestFinish = INT\_MAX;

&#x20;       for (int i = 0; i < states.size(); i++) {

&#x20;           if (states\[i].remainingCap < o.demand) continue;

&#x20;           int arrival = max(states\[i].currentTime, o.readyTime);

&#x20;           int finish = arrival + o.serviceTime;

&#x20;           if (finish <= o.dueTime && finish < bestFinish) {

&#x20;               bestFinish = finish; best = i;

&#x20;           }

&#x20;       }

&#x20;       if (best == -1) unassigned.push\_back(o.orderId);

&#x20;       else { ... æ›´æ–°è½¦è¾†çŠ¶æ€ ... }

&#x20;   }

&#x20;   ...

}



2.2 æ ¸å¿ƒç®—æ³•æµç¨‹

æ­¥éª¤1ï¼šè®¢å•é¢„å¤„ç†

* æŒ‰ dueTime å‡åºæ’åºï¼Œä¿è¯ç´§æ€¥è®¢å•ä¼˜å…ˆã€‚

æ­¥éª¤2ï¼šè½¦è¾†çŠ¶æ€åˆå§‹åŒ–

* å¯¹æ¯è¾†è½¦è®°å½• remainingCapã€currentTimeï¼ˆèµ·å§‹ä¸º startTimeï¼‰ã€å·²åˆ†é…è®¢å•åˆ—è¡¨ã€‚

æ­¥éª¤3ï¼šé€å•åˆ†é…

* è®¡ç®—è½¦è¾†åˆ°è¾¾æ—¶é—´ arrival = max(currentTime, readyTime)ï¼Œå®Œæˆæ—¶é—´ finish = arrival + serviceTimeã€‚

* å¯è¡Œæ€§ï¼šfinish â‰¤ dueTime ä¸” remainingCap â‰¥ demandã€‚

* åœ¨å¯è¡Œè½¦è¾†ä¸­é€‰ finish æœ€æ—©è€…ï¼›æ— å¯è¡Œåˆ™åŠ å…¥æœªåˆ†é…åˆ—è¡¨ã€‚

æ­¥éª¤4ï¼šçŠ¶æ€æ›´æ–°

* è½¦è¾†å‰©ä½™å®¹é‡æ‰£å‡ï¼ŒcurrentTime æ¨è¿›åˆ°é€‰å®šè®¢å•çš„ finishï¼Œæ€»éœ€æ±‚ç´¯åŠ ã€‚

æ­¥éª¤5ï¼šç»“æœæ•´ç†

* è¾“å‡ºæ¯è¾†è½¦çš„è®¢å•åºåˆ—ä¸å®Œæˆæ—¶é—´ï¼›æç¤ºæœªåˆ†é…è®¢å•åˆ—è¡¨ã€‚



2.3 å…³é”®çº¦æŸè¯´æ˜

* å®¹é‡çº¦æŸï¼šä¸€æ¬¡åˆ†é…ç›´æ¥æ‰£å‡ï¼Œä¿è¯ä¸è¶…è½½ã€‚

* æ—¶é—´çª—ï¼šè‹¥è½¦è¾†æ—©åˆ°ï¼Œå¯ç­‰å¾…è‡³ readyTimeï¼›è‹¥ finish è¶…è¿‡ dueTime ç›´æ¥åˆ¤ä¸ºä¸å¯è¡Œã€‚

* èµ·å§‹æ—¶é—´ï¼šä½¿ç”¨è½¦è¾† startTime ä½œä¸ºåˆå§‹ currentTimeï¼Œå¯å»ºæ¨¡ç­æ¬¡/æ—¶æ®µé™åˆ¶ã€‚



### ä¸‰ã€è´ªå¿ƒç­–ç•¥åˆç†æ€§åˆ†æ

* æˆªæ­¢æ—¶é—´ä¼˜å…ˆï¼ˆEDDï¼‰æ˜¯ç»å…¸å•æœºæœ€å°‘å»¶è¿Ÿå¯å‘å¼ï¼Œå°†â€œç´§æ€¥â€è®¢å•æ”¾åœ¨å‰é¢ï¼Œé™ä½è¿çº¦æ¦‚ç‡ã€‚

* â€œæœ€æ—©å®Œæˆâ€è½¦è¾†é€‰æ‹©æœ€å°åŒ–å½“å‰è®¢å•å ç”¨æ—¶é—´ï¼Œé‡Šæ”¾æ›´å¤šåç»­å¯è¡Œæ€§ç©ºé—´ã€‚

* è™½éå…¨å±€æœ€ä¼˜ï¼Œä½†åœ¨æ—¶é—´çª—+å®¹é‡åŒçº¦æŸä¸‹ï¼Œè®¡ç®—é‡ O( |Orders| Ã— |Vehicles| )ï¼Œå¯å¿«é€Ÿå¾—åˆ°é«˜å¯è¡Œç‡æ–¹æ¡ˆï¼Œé€‚åˆä½œä¸ºåŸºçº¿æˆ–ä¸Šç•Œ/ä¸‹ç•Œåˆå§‹åŒ–ã€‚

* æœªåˆ†é…è®¢å•æ˜¾å¼è¾“å‡ºï¼Œä¾¿äºåç»­äºŒæ¬¡ä¼˜åŒ–æˆ–äººå·¥å¹²é¢„ã€‚



### å››ã€å®éªŒç»“æœå‘ˆç°è¦ç‚¹

* æ¯è¾†è½¦ï¼šå·²åˆ†é…è®¢å•åˆ—è¡¨ã€æ€»éœ€æ±‚ã€é¢„è®¡å®Œæˆæ—¶é—´ã€‚

* æœªåˆ†é…è®¢å•ï¼šå› å®¹é‡æˆ–æ—¶é—´çª—æ— æ³•æ»¡è¶³çš„è®¢å•ç¼–å·ã€‚

* ç»“åˆåç»­è·¯ç”±æ¨¡å—ï¼šè½¦è¾†è·å¾—è®¢å•åå†è¿›è¡Œè·¯å¾„ä¼˜åŒ–ï¼ˆè´ªå¿ƒæˆ–2-opt/ç²¾ç¡®å°è§„æ¨¡ TSPï¼‰ï¼Œæœ¬æ¨¡å—ä¸“æ³¨â€œå“ªä¸ªè½¦æ¥å“ªä¸ªå•â€ã€‚

#### æµç¨‹å›¾

1ã€è½¦è¾†è°ƒåº¦æ•´ä½“ç®—æ³•æµç¨‹å›¾

![](images/image-12.png)

2ã€ è®¢å• - è½¦è¾†å¯è¡Œæ€§åˆ¤å®šå­æµç¨‹å›¾

![](images/image-11.png)

3ã€æœ€ä¼˜è½¦è¾†é€‰æ‹©å­æµç¨‹å›¾

![](images/image-9.png)

### äº”ã€ä¸ªäººå¿ƒå¾—ä¸å°ç»“

* å¯å‘å¼æ’åº + æœ€æ—©å®Œæˆé€‰æ‹©ï¼Œåœ¨æ—¶é—´çª—åœºæ™¯ä¸‹æ¯”å•çº¯å®¹é‡è´ªå¿ƒæ›´ç¨³å¥ã€‚

* è½¦è¾† currentTime å…è®¸ç­‰å¾…ï¼Œæ˜¾å¼å¤„ç† readyTimeï¼Œå¯å…¼é¡¾æ—©çª—è®¢å•ã€‚

* æœªåˆ†é…æ¸…å•æ˜¯å¿…è¦çš„åé¦ˆå£ï¼šè®©è°ƒåº¦è€…å¿«é€Ÿå®šä½ç“¶é¢ˆï¼ˆè½¦è¾†ä¸è¶³ã€çª—å£è¿‡ç´§ï¼‰ã€‚

* åç»­å¯æ”¹è¿›æ–¹å‘ï¼š

* å¼•å…¥â€œæ¾å¼›åº¦ slack = dueTime - readyTime - serviceTimeâ€äºŒçº§æ’åºï¼›

* å…è®¸å±€éƒ¨é‡æ’ï¼ˆå¦‚äº¤æ¢/æ’å…¥ï¼‰æå‡å¯è¡Œç‡ï¼›

* åŠ å…¥è¡Œé©¶æ—¶é—´ä¼°è®¡ï¼Œå°†â€œæœ€æ—©å®Œæˆâ€æ”¹ä¸ºâ€œæœ€æ—©å¯è¿”å›â€æˆ–â€œæœ€å°å¢é‡è¡Œé©¶æ—¶é—´â€çš„è¯„ä»·ã€‚

***

# ğŸ‘¤ æ¢…å­èˆª â€”â€” åº“å­˜ä¼˜åŒ–æ¨¡å—ï¼ˆåŠ¨æ€è§„åˆ’ï¼‰

### è´Ÿè´£å†…å®¹

* åº“å­˜è¡¥è´§ DP å®ç°

* é¢„ç®—çº¦æŸä¸‹çš„å†³ç­–

* å›æº¯è¡¥è´§æ–¹æ¡ˆ

### æŠ¥å‘Šè´Ÿè´£ç« èŠ‚

* ã€Œåº“å­˜ä¼˜åŒ–æ¨¡å‹ã€

* DP çŠ¶æ€å®šä¹‰ä¸è½¬ç§»

* ä¸åŒé¢„ç®—ä¸‹çš„å¯¹æ¯”å®éªŒ





**ä¸€ã€å®éªŒåŸç†**

1.1 æ•°å­¦æ¨¡å‹

æœ¬æ¨¡å—å°†åº“å­˜ä¼˜åŒ–é—®é¢˜å»ºæ¨¡ä¸ºä¸€ä¸ªå¸¦çº¦æŸçš„ä¼˜åŒ–é—®é¢˜ï¼š

ã€ç›®æ ‡å‡½æ•°ã€‘

æœ€å°åŒ–æ€»ç¼ºè´§ç½šé‡‘ï¼šmin Î£(ç¼ºè´§é‡\_i Ã— å•ä½ç½šé‡‘\_i)

ã€çº¦æŸæ¡ä»¶ã€‘

* æ€»è¡¥è´§æˆæœ¬ â‰¤ é¢„ç®—ä¸Šé™ B

* æ¯ä¸ªç‰©å“å¯ä»¥é€‰æ‹©ä¸€ä¸ªè¡¥è´§æ–¹æ¡ˆæˆ–ä¸è¡¥è´§

* ç¼ºè´§é‡ = max(0, éœ€æ±‚ - (ç°æœ‰åº“å­˜ + è¡¥è´§é‡))

ã€å†³ç­–å˜é‡ã€‘

å¯¹äºæ¯ä¸ªç‰©å“ iï¼Œä»ä»¥ä¸‹é€‰é¡¹ä¸­é€‰æ‹©å…¶ä¸€ï¼š

* ä¸è¡¥è´§ï¼ˆæˆæœ¬=0ï¼Œè¡¥è´§é‡=0ï¼‰

* é€‰æ‹©è¡¥è´§æ–¹æ¡ˆ kï¼ˆæˆæœ¬=cost\_kï¼Œè¡¥è´§é‡=qty\_kï¼‰



1.2 åŠ¨æ€è§„åˆ’åŸç†

è¯¥é—®é¢˜å…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼Œé€‚åˆä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ï¼š

ï¼ˆ1ï¼‰æœ€ä¼˜å­ç»“æ„ï¼šå‰ i ä¸ªç‰©å“çš„æœ€ä¼˜å†³ç­–åŒ…å«å‰ i-1 ä¸ªç‰©å“çš„æœ€ä¼˜å†³ç­–

ï¼ˆ2ï¼‰é‡å å­é—®é¢˜ï¼šä¸åŒé¢„ç®—ä¸‹çš„å­é—®é¢˜å¯èƒ½é‡å¤è®¡ç®—

ï¼ˆ3ï¼‰æ— åæ•ˆæ€§ï¼šå½“å‰å†³ç­–åªä¾èµ–äºå·²å¤„ç†çš„ç‰©å“å’Œå‰©ä½™é¢„ç®—

ã€DPçŠ¶æ€å®šä¹‰ã€‘

dp\[i]\[b] = å¤„ç†å‰ i ä¸ªç‰©å“ï¼Œä½¿ç”¨é¢„ç®—ä¸è¶…è¿‡ b æ—¶çš„æœ€å°ç¼ºè´§ç½šé‡‘

ã€çŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‘

å¯¹äºç‰©å“ iï¼Œåœ¨é¢„ç®— b ä¸‹ï¼š

* ä¸è¡¥è´§ï¼šdp\[i]\[b] = dp\[i-1]\[b] + penalty(i, 0)

* é€‰æ‹©æ–¹æ¡ˆ kï¼šdp\[i]\[b] = min(dp\[i-1]\[b-cost\_k] + penalty(i, qty\_k))

å…¶ä¸­ penalty(i, qty) = max(0, demand\_i - (onHand\_i + qty)) Ã— unitPenalty\_i

ã€æ—¶é—´å¤æ‚åº¦ã€‘

O(n Ã— B Ã— K)ï¼Œå…¶ä¸­ï¼š

* nï¼šç‰©å“æ•°é‡

* Bï¼šé¢„ç®—ä¸Šé™

* Kï¼šæ¯ä¸ªç‰©å“çš„å¹³å‡è¡¥è´§æ–¹æ¡ˆæ•°

ã€ç©ºé—´å¤æ‚åº¦ã€‘

O(n Ã— B)ï¼Œç”¨äºå­˜å‚¨DPè¡¨å’Œé€‰æ‹©è®°å½•è¡¨



1.3 å›æº¯æ±‚è§£æœ€ä¼˜æ–¹æ¡ˆ

åœ¨å®ŒæˆDPè®¡ç®—åï¼Œé€šè¿‡choice\[i]\[b]è®°å½•è¡¨å›æº¯ï¼Œæ‰¾åˆ°æœ€ä¼˜çš„è¡¥è´§æ–¹æ¡ˆåºåˆ—ï¼š

ï¼ˆ1ï¼‰åœ¨dp\[n]\[0..B]ä¸­æ‰¾åˆ°æœ€å°ç½šé‡‘å¯¹åº”çš„é¢„ç®—bestB

ï¼ˆ2ï¼‰ä»ç‰©å“nåˆ°ç‰©å“1ï¼Œæ ¹æ®choiceè¡¨å›æº¯æ¯ä¸ªç‰©å“çš„é€‰æ‹©

ï¼ˆ3ï¼‰è¾“å‡ºå®Œæ•´çš„è¡¥è´§æ–¹æ¡ˆå’Œç»Ÿè®¡ä¿¡æ¯



**äºŒã€å®éªŒå†…å®¹**

2.1 æ•°æ®ç»“æ„è®¾è®¡

ã€InventoryOptionç»“æ„ä½“ã€‘

ç”¨äºè¡¨ç¤ºå•ä¸ªè¡¥è´§æ–¹æ¡ˆï¼š

* qtyï¼šè¡¥è´§æ•°é‡

* costï¼šè¡¥è´§æˆæœ¬

ã€InventoryItemç»“æ„ä½“ã€‘

ç”¨äºè¡¨ç¤ºåº“å­˜ç‰©å“ä¿¡æ¯ï¼š

* nameï¼šç‰©å“åç§°

* onHandï¼šç°æœ‰åº“å­˜é‡

* demandï¼šéœ€æ±‚é‡

* unitPenaltyï¼šå•ä½ç¼ºè´§ç½šé‡‘ï¼ˆæ•°å€¼è¶Šå¤§ï¼Œè¡¨ç¤ºè¯¥ç‰©å“è¶Šé‡è¦ï¼‰

* optionsï¼šè¯¥ç‰©å“çš„æ‰€æœ‰å¯é€‰è¡¥è´§æ–¹æ¡ˆåˆ—è¡¨



2.2 æ ¸å¿ƒç®—æ³•å®ç°

ã€å‡½æ•°ï¼šoptimizeInventoryDPã€‘

åŠŸèƒ½ï¼šä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£é¢„ç®—çº¦æŸä¸‹çš„åº“å­˜è¡¥è´§ä¼˜åŒ–é—®é¢˜

ã€ç®—æ³•æµç¨‹ã€‘

æ­¥éª¤1ï¼šåˆå§‹åŒ–

* åˆ›å»ºDPè¡¨dp\[n+1]\[budget+1]ï¼Œåˆå§‹åŒ–ä¸ºæ— ç©·å¤§

* åˆ›å»ºé€‰æ‹©è®°å½•è¡¨choice\[n+1]\[budget+1]ï¼Œç”¨äºå›æº¯

* è®¾ç½®è¾¹ç•Œæ¡ä»¶ï¼šdp\[0]\[0] = 0ï¼ˆå‰0ä¸ªç‰©å“ï¼Œé¢„ç®—0ï¼Œç½šé‡‘ä¸º0ï¼‰

æ­¥éª¤2ï¼šçŠ¶æ€è½¬ç§»

å¯¹äºæ¯ä¸ªç‰©å“iï¼ˆä»1åˆ°nï¼‰ï¼š

&#x20; å¯¹äºæ¯ä¸ªé¢„ç®—bï¼ˆä»0åˆ°budgetï¼‰ï¼š

&#x20;   ï¼ˆ1ï¼‰è€ƒè™‘ä¸è¡¥è´§çš„æƒ…å†µ

&#x20;       \- å¦‚æœdp\[i-1]\[b]å¯è¾¾ï¼Œè®¡ç®—ä¸è¡¥è´§çš„ç½šé‡‘

&#x20;       \- æ›´æ–°dp\[i]\[b]å’Œchoice\[i]\[b]

&#x20;   ï¼ˆ2ï¼‰è€ƒè™‘æ¯ä¸ªè¡¥è´§æ–¹æ¡ˆk

&#x20;       \- å¦‚æœé¢„ç®—b >= cost\_k ä¸” dp\[i-1]\[b-cost\_k]å¯è¾¾

&#x20;       \- è®¡ç®—é€‰æ‹©æ–¹æ¡ˆkåçš„ç½šé‡‘

&#x20;       \- å¦‚æœæ›´ä¼˜ï¼Œæ›´æ–°dp\[i]\[b]å’Œchoice\[i]\[b]

æ­¥éª¤3ï¼šå¯»æ‰¾æœ€ä¼˜é¢„ç®—ç‚¹

* éå†dp\[n]\[0..budget]ï¼Œæ‰¾åˆ°æœ€å°ç½šé‡‘å¯¹åº”çš„é¢„ç®—bestB

æ­¥éª¤4ï¼šå›æº¯æœ€ä¼˜æ–¹æ¡ˆ

* ä»ç‰©å“nåˆ°ç‰©å“1ï¼Œæ ¹æ®choiceè¡¨å›æº¯

* è®°å½•æ¯ä¸ªç‰©å“é€‰æ‹©çš„è¡¥è´§æ–¹æ¡ˆï¼ˆ-1è¡¨ç¤ºä¸è¡¥è´§ï¼‰

æ­¥éª¤5ï¼šè¾“å‡ºç»“æœ

* æ˜¾ç¤ºæœ€ä¼˜é¢„ç®—ä½¿ç”¨æƒ…å†µ

* æ˜¾ç¤ºæœ€å°ç¼ºè´§ç½šé‡‘

* ä»¥è¡¨æ ¼å½¢å¼è¾“å‡ºæ¯ä¸ªç‰©å“çš„è¯¦ç»†ä¿¡æ¯ï¼š

  * ç‰©å“åç§°ã€ç°æœ‰åº“å­˜ã€éœ€æ±‚é‡

  * é€‰æ‹©çš„è¡¥è´§é‡å’Œæˆæœ¬

  * ç¼ºè´§é‡å’Œç½šé‡‘

* æ˜¾ç¤ºæ€»æˆæœ¬å’Œæ€»ç½šé‡‘



2.3 å…³é”®å‡½æ•°è¯´æ˜

ã€penaltyå‡½æ•°ï¼ˆLambdaè¡¨è¾¾å¼ï¼‰ã€‘

è®¡ç®—ç»™å®šè¡¥è´§é‡ä¸‹çš„ç¼ºè´§ç½šé‡‘ï¼š

penalty(item, addQty) = max(0, demand - (onHand + addQty)) Ã— unitPenalty

è¯¥å‡½æ•°åœ¨DPè½¬ç§»è¿‡ç¨‹ä¸­è¢«é¢‘ç¹è°ƒç”¨ï¼Œç”¨äºè®¡ç®—ä¸åŒå†³ç­–ä¸‹çš„ç½šé‡‘å€¼ã€‚



**ä¸‰ã€å°ç»„åˆ†å·¥å’Œæ‰¿æ‹…å…·ä½“ä»»åŠ¡**

3.1 å°ç»„åˆ†å·¥

| æˆå‘˜  | è§’è‰² | ä¸»è¦èŒè´£                                   | å…·ä½“ä»»åŠ¡æ¨¡å—                                                              |
| --- | -- | -------------------------------------- | ------------------------------------------------------------------- |
| æ¢…å­èˆª | ç»„å‘˜ |                     åº“å­˜ä¼˜åŒ–æ¨¡å—ï¼ŒåŠ¨æ€è§„åˆ’ç®—æ³•ï¼Œå›æº¯æ–¹æ¡ˆ |              1.åº“å­˜ä¼˜åŒ–æ¨¡å‹è®¾è®¡             2.åŠ¨æ€è§„åˆ’ç®—æ³•å®ç°             3.å›æº¯æ–¹æ¡ˆæ±‚è§£ |

3.2 æ‰¿æ‹…å…·ä½“ä»»åŠ¡

ï¼ˆ1ï¼‰åº“å­˜ä¼˜åŒ–æ¨¡å‹è®¾è®¡

ï¼ˆ2ï¼‰åŠ¨æ€è§„åˆ’ç®—æ³•å®ç°

ï¼ˆ3ï¼‰å›æº¯æ–¹æ¡ˆæ±‚è§£



å®ç°æ­¥éª¤å’Œè¿‡ç¨‹

3.2.1 ä»»åŠ¡1ï¼šåº“å­˜ä¼˜åŒ–æ¨¡å‹è®¾è®¡

ã€æ­¥éª¤1ï¼šé—®é¢˜åˆ†æã€‘

ï¼ˆ1ï¼‰é˜…è¯»é¡¹ç›®éœ€æ±‚ï¼Œç†è§£åº“å­˜ä¼˜åŒ–çš„ä¸šåŠ¡åœºæ™¯

ï¼ˆ2ï¼‰åˆ†æé—®é¢˜çš„æ ¸å¿ƒè¦ç´ ï¼š

* å¤šä¸ªç‰©å“ï¼Œæ¯ä¸ªç‰©å“æœ‰ç°æœ‰åº“å­˜ã€éœ€æ±‚é‡ã€å•ä½ç½šé‡‘

* æ¯ä¸ªç‰©å“æœ‰å¤šä¸ªè¡¥è´§æ–¹æ¡ˆå¯é€‰ï¼ˆä¸åŒæ•°é‡ã€ä¸åŒæˆæœ¬ï¼‰

* æ€»é¢„ç®—æœ‰é™ï¼Œéœ€è¦åˆç†åˆ†é…

* ç›®æ ‡æ˜¯æœ€å°åŒ–ç¼ºè´§ç½šé‡‘

ï¼ˆ3ï¼‰ç¡®å®šé—®é¢˜çš„æ•°å­¦ç‰¹å¾ï¼š

* è¿™æ˜¯ä¸€ä¸ªå¸¦çº¦æŸçš„ä¼˜åŒ–é—®é¢˜

* å…·æœ‰æœ€ä¼˜å­ç»“æ„æ€§è´¨

* é€‚åˆç”¨åŠ¨æ€è§„åˆ’æ±‚è§£



ã€æ­¥éª¤2ï¼šæ•°å­¦æ¨¡å‹å»ºç«‹ã€‘

ï¼ˆ1ï¼‰å®šä¹‰å†³ç­–å˜é‡ï¼š

* å¯¹äºç‰©å“iï¼Œé€‰æ‹©è¡¥è´§æ–¹æ¡ˆkï¼ˆk=-1è¡¨ç¤ºä¸è¡¥è´§ï¼‰

ï¼ˆ2ï¼‰å»ºç«‹ç›®æ ‡å‡½æ•°ï¼š

&#x20;  min Î£ max(0, demand\_i - (onHand\_i + qty\_i)) Ã— unitPenalty\_i

ï¼ˆ3ï¼‰å»ºç«‹çº¦æŸæ¡ä»¶ï¼š

&#x20;  Î£ cost\_i â‰¤ budget

ï¼ˆ4ï¼‰ç¡®å®šçŠ¶æ€ç©ºé—´ï¼š

&#x20;  dp\[i]\[b] = å‰iä¸ªç‰©å“ï¼Œé¢„ç®—bä¸‹çš„æœ€å°ç½šé‡‘



ã€æ­¥éª¤3ï¼šçŠ¶æ€è½¬ç§»æ–¹ç¨‹æ¨å¯¼ã€‘

ï¼ˆ1ï¼‰åˆ†æçŠ¶æ€è½¬ç§»çš„ä¸¤ç§æƒ…å†µï¼š

* ä¸è¡¥è´§ï¼šdp\[i]\[b] = dp\[i-1]\[b] + penalty(i, 0)

* è¡¥è´§æ–¹æ¡ˆkï¼šdp\[i]\[b] = dp\[i-1]\[b-cost\_k] + penalty(i, qty\_k)

ï¼ˆ2ï¼‰ç¡®å®šè¾¹ç•Œæ¡ä»¶ï¼š

* dp\[0]\[0] = 0ï¼ˆå‰0ä¸ªç‰©å“ï¼Œé¢„ç®—0ï¼Œç½šé‡‘ä¸º0ï¼‰

* å…¶ä»–çŠ¶æ€åˆå§‹åŒ–ä¸ºæ— ç©·å¤§

ï¼ˆ3ï¼‰éªŒè¯è½¬ç§»æ–¹ç¨‹çš„æ­£ç¡®æ€§ï¼š

* ç¡®ä¿è¦†ç›–æ‰€æœ‰å¯èƒ½çš„å†³ç­–

* ç¡®ä¿æ— åæ•ˆæ€§



3.2.2 ä»»åŠ¡2ï¼šåŠ¨æ€è§„åˆ’ç®—æ³•å®ç°

ã€æ­¥éª¤1ï¼šæ•°æ®ç»“æ„å‡†å¤‡ã€‘

ï¼ˆ1ï¼‰å®šä¹‰InventoryOptionç»“æ„ä½“ï¼š

```c++
struct InventoryOption {
    int qty{};   // è¡¥è´§æ•°é‡
    int cost{};  // è¡¥è´§æˆæœ¬
};
```

ï¼ˆ2ï¼‰å®šä¹‰InventoryItemç»“æ„ä½“ï¼š

```c++
struct InventoryItem {
    string name;                    // ç‰©å“åç§°
    int onHand{};                   // ç°æœ‰åº“å­˜
    int demand{};                   // éœ€æ±‚é‡
    int unitPenalty{};              // å•ä½ç¼ºè´§ç½šé‡‘
    vector<InventoryOption> options; // è¡¥è´§æ–¹æ¡ˆåˆ—è¡¨
};
```



ã€æ­¥éª¤2ï¼šæ ¸å¿ƒå‡½æ•°æ¡†æ¶æ­å»ºã€‘

ï¼ˆ1ï¼‰åˆ›å»ºoptimizeInventoryDPå‡½æ•°ç­¾åï¼š

* å‚æ•°ï¼šç‰©å“åˆ—è¡¨itemsï¼Œé¢„ç®—ä¸Šé™budget

* è¿”å›ï¼švoidï¼ˆç»“æœé€šè¿‡è¾“å‡ºæ˜¾ç¤ºï¼‰

ï¼ˆ2ï¼‰åˆå§‹åŒ–å˜é‡ï¼š

* n = ç‰©å“æ•°é‡

* INF = æ— ç©·å¤§å¸¸é‡ï¼ˆä½¿ç”¨long longé¿å…æº¢å‡ºï¼‰



ã€æ­¥éª¤3ï¼šDPè¡¨åˆå§‹åŒ–ã€‘

ï¼ˆ1ï¼‰åˆ›å»ºDPè¡¨ï¼š

&#x20;  vector\<vector\<long long>> dp(n+1, vector\<long long>(budget+1, INF));

* ç»´åº¦ï¼šn+1è¡Œï¼ˆ0åˆ°nä¸ªç‰©å“ï¼‰ï¼Œbudget+1åˆ—ï¼ˆ0åˆ°budgeté¢„ç®—ï¼‰

* åˆå§‹å€¼ï¼šå…¨éƒ¨è®¾ä¸ºINF

ï¼ˆ2ï¼‰åˆ›å»ºé€‰æ‹©è®°å½•è¡¨ï¼š

&#x20;  vector\<vector\<int>> choice(n+1, vector\<int>(budget+1, -1));

* ç”¨äºè®°å½•æ¯ä¸ªçŠ¶æ€çš„æœ€ä¼˜é€‰æ‹©

* -1è¡¨ç¤ºä¸è¡¥è´§ï¼Œkè¡¨ç¤ºé€‰æ‹©ç¬¬kä¸ªè¡¥è´§æ–¹æ¡ˆ

ï¼ˆ3ï¼‰è®¾ç½®è¾¹ç•Œæ¡ä»¶ï¼š

&#x20;  dp\[0]\[0] = 0;  // å‰0ä¸ªç‰©å“ï¼Œé¢„ç®—0ï¼Œç½šé‡‘ä¸º0



ã€æ­¥éª¤4ï¼šå®ç°ç½šé‡‘è®¡ç®—å‡½æ•°ã€‘

ï¼ˆ1ï¼‰ä½¿ç”¨Lambdaè¡¨è¾¾å¼å®šä¹‰penaltyå‡½æ•°ï¼š

```c++
auto penalty = [&](const InventoryItem& it, int addQty) -> long long {
    int have = it.onHand + addQty;
    int shortage = max(0, it.demand - have);
    return 1LL * shortage * it.unitPenalty;
};
```

ï¼ˆ2ï¼‰åŠŸèƒ½è¯´æ˜ï¼š

* è®¡ç®—ç»™å®šè¡¥è´§é‡ä¸‹çš„ç¼ºè´§é‡

* ç¼ºè´§é‡ = max(0, éœ€æ±‚ - (ç°æœ‰ + è¡¥è´§))

* è¿”å›ç¼ºè´§ç½šé‡‘ = ç¼ºè´§é‡ Ã— å•ä½ç½šé‡‘



ã€æ­¥éª¤5ï¼šå®ç°çŠ¶æ€è½¬ç§»ã€‘

ï¼ˆ1ï¼‰å¤–å±‚å¾ªç¯ï¼šéå†æ¯ä¸ªç‰©å“

&#x20;  for (int i = 1; i <= n; i++)

ï¼ˆ2ï¼‰å†…å±‚å¾ªç¯ï¼šéå†æ¯ä¸ªé¢„ç®—å€¼

&#x20;  for (int b = 0; b <= budget; b++)

ï¼ˆ3ï¼‰æƒ…å†µ1ï¼šä¸è¡¥è´§

* æ£€æŸ¥å‰ä¸€ä¸ªçŠ¶æ€æ˜¯å¦å¯è¾¾ï¼šdp\[i-1]\[b] < INF

* è®¡ç®—ä¸è¡¥è´§çš„ç½šé‡‘ï¼šval = dp\[i-1]\[b] + penalty(it, 0)

* å¦‚æœæ›´ä¼˜ï¼Œæ›´æ–°dp\[i]\[b]å’Œchoice\[i]\[b] = -1

ï¼ˆ4ï¼‰æƒ…å†µ2ï¼šé€‰æ‹©è¡¥è´§æ–¹æ¡ˆ

* éå†è¯¥ç‰©å“çš„æ‰€æœ‰è¡¥è´§æ–¹æ¡ˆ

* æ£€æŸ¥é¢„ç®—æ˜¯å¦è¶³å¤Ÿï¼šb >= cost

* æ£€æŸ¥å‰ä¸€ä¸ªçŠ¶æ€æ˜¯å¦å¯è¾¾ï¼šdp\[i-1]\[b-cost] < INF

* è®¡ç®—é€‰æ‹©è¯¥æ–¹æ¡ˆçš„ç½šé‡‘ï¼šval = dp\[i-1]\[b-cost] + penalty(it, qty)

* å¦‚æœæ›´ä¼˜ï¼Œæ›´æ–°dp\[i]\[b]å’Œchoice\[i]\[b] = k



ã€æ­¥éª¤6ï¼šè°ƒè¯•å’Œä¼˜åŒ–ã€‘

ï¼ˆ1ï¼‰æ·»åŠ è°ƒè¯•è¾“å‡ºï¼ŒéªŒè¯çŠ¶æ€è½¬ç§»æ­£ç¡®æ€§

ï¼ˆ2ï¼‰æ£€æŸ¥è¾¹ç•Œæƒ…å†µå¤„ç†

ï¼ˆ3ï¼‰ä¼˜åŒ–ä»£ç ç»“æ„ï¼Œæé«˜å¯è¯»æ€§



3.2.3 ä»»åŠ¡3ï¼šå›æº¯æ–¹æ¡ˆæ±‚è§£

ã€æ­¥éª¤1ï¼šå¯»æ‰¾æœ€ä¼˜é¢„ç®—ç‚¹ã€‘

ï¼ˆ1ï¼‰éå†æ‰€æœ‰é¢„ç®—å€¼ï¼š

```c++
int bestB = 0;
for (int b = 1; b <= budget; b++) {
    if (dp[n][b] < dp[n][bestB]) bestB = b;
}
```

ï¼ˆ2ï¼‰åŠŸèƒ½è¯´æ˜ï¼š

* åœ¨æ‰€æœ‰é¢„ç®—ä¸‹ï¼Œæ‰¾åˆ°æœ€å°ç½šé‡‘å¯¹åº”çš„é¢„ç®—å€¼

* æœ€ä¼˜ä½¿ç”¨é¢„ç®—å¯èƒ½å°äºé¢„ç®—ä¸Šé™



ã€æ­¥éª¤2ï¼šå›æº¯æ„é€ æœ€ä¼˜æ–¹æ¡ˆã€‘

ï¼ˆ1ï¼‰åˆå§‹åŒ–å›æº¯å˜é‡ï¼š

* pickedæ•°ç»„ï¼šè®°å½•æ¯ä¸ªç‰©å“é€‰æ‹©çš„æ–¹æ¡ˆï¼ˆ-1è¡¨ç¤ºä¸è¡¥è´§ï¼‰

* b = bestBï¼šä»æœ€ä¼˜é¢„ç®—å¼€å§‹å›æº¯

ï¼ˆ2ï¼‰ä»åå¾€å‰å›æº¯ï¼š

```c++
for (int i = n; i >= 1; i--) {
    int c = choice[i][b];
    picked[i-1] = c;
    if (c != -1) b -= items[i-1].options[c].cost;
}
```

ï¼ˆ3ï¼‰å›æº¯é€»è¾‘ï¼š

* ä»æœ€åä¸€ä¸ªç‰©å“å¼€å§‹

* æ ¹æ®choiceè¡¨ç¡®å®šè¯¥ç‰©å“çš„é€‰æ‹©

* å¦‚æœé€‰æ‹©äº†è¡¥è´§æ–¹æ¡ˆï¼Œä»é¢„ç®—ä¸­æ‰£é™¤æˆæœ¬

* ç»§ç»­å›æº¯å‰ä¸€ä¸ªç‰©å“



ã€æ­¥éª¤3ï¼šéªŒè¯å›æº¯ç»“æœã€‘

ï¼ˆ1ï¼‰æ£€æŸ¥å›æº¯è·¯å¾„çš„åˆæ³•æ€§

ï¼ˆ2ï¼‰éªŒè¯æ€»æˆæœ¬ä¸è¶…è¿‡æœ€ä¼˜é¢„ç®—

ï¼ˆ3ï¼‰éªŒè¯æ€»ç½šé‡‘ç­‰äºdp\[n]\[bestB]



### å››ã€ä¸ªäººå¿ƒå¾—ä¸å°ç»“

4.1 ç®—æ³•è®¾è®¡å¿ƒå¾—

ã€åŠ¨æ€è§„åˆ’çš„é€‰æ‹©ã€‘

æœ€åˆè€ƒè™‘è¿‡è´ªå¿ƒç®—æ³•ï¼Œä½†å‘ç°è´ªå¿ƒæ— æ³•ä¿è¯å…¨å±€æœ€ä¼˜ã€‚åŠ¨æ€è§„åˆ’èƒ½å¤Ÿç³»ç»Ÿåœ°

è€ƒè™‘æ‰€æœ‰å¯èƒ½çš„å†³ç­–ç»„åˆï¼Œåœ¨é¢„ç®—çº¦æŸä¸‹æ‰¾åˆ°çœŸæ­£çš„æœ€ä¼˜è§£ã€‚è¿™è®©æˆ‘æ·±åˆ»ç†è§£

äº†"å±€éƒ¨æœ€ä¼˜ä¸ç­‰äºå…¨å±€æœ€ä¼˜"çš„é“ç†ã€‚

ã€çŠ¶æ€è®¾è®¡çš„æŠ€å·§ã€‘

DPçŠ¶æ€çš„è®¾è®¡æ˜¯å…³é”®ã€‚é€‰æ‹©"å‰iä¸ªç‰©å“ï¼Œé¢„ç®—b"ä½œä¸ºçŠ¶æ€ï¼Œæ—¢ä¿è¯äº†æ— åæ•ˆæ€§ï¼Œ

åˆä½¿å¾—çŠ¶æ€è½¬ç§»æ¸…æ™°è‡ªç„¶ã€‚choiceè¡¨çš„å¼•å…¥è™½ç„¶å¢åŠ äº†ç©ºé—´å¤æ‚åº¦ï¼Œä½†å¤§å¤§ç®€åŒ–

äº†å›æº¯è¿‡ç¨‹ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æƒè¡¡ã€‚

ã€è¾¹ç•Œæ¡ä»¶çš„å¤„ç†ã€‘

åˆå§‹åŒ–dp\[0]\[0]=0ï¼Œå…¶ä»–ä¸ºæ— ç©·å¤§ï¼Œç¡®ä¿äº†åªæœ‰åˆæ³•çš„çŠ¶æ€è½¬ç§»æ‰ä¼šè¢«è€ƒè™‘ã€‚

è¿™ç§è®¾è®¡é¿å…äº†å¤æ‚çš„è¾¹ç•Œåˆ¤æ–­ï¼Œè®©ä»£ç æ›´åŠ ç®€æ´å¯é ã€‚



4.2 ç®—æ³•ä¼˜åŒ–æ€è€ƒ

ã€å½“å‰å®ç°çš„ä¼˜ç‚¹ã€‘

* æ—¶é—´å¤æ‚åº¦åˆç†ï¼šO(nÃ—BÃ—K)å¯¹äºå®é™…åº”ç”¨å¯æ¥å—

* ç©ºé—´å¤æ‚åº¦å¯æ§ï¼šO(nÃ—B)å¯ä»¥é€šè¿‡æ»šåŠ¨æ•°ç»„ä¼˜åŒ–åˆ°O(B)

* èƒ½å¤Ÿå¤„ç†å¤šç‰©å“ã€å¤šæ–¹æ¡ˆçš„å¤æ‚åœºæ™¯

* è¾“å‡ºä¿¡æ¯å®Œæ•´ï¼Œä¾¿äºå†³ç­–åˆ†æ

ã€å¯èƒ½çš„æ”¹è¿›æ–¹å‘ã€‘

ï¼ˆ1ï¼‰ç©ºé—´ä¼˜åŒ–ï¼šä½¿ç”¨æ»šåŠ¨æ•°ç»„å°†ç©ºé—´å¤æ‚åº¦é™è‡³O(B)

ï¼ˆ2ï¼‰å‰ªæä¼˜åŒ–ï¼šå¯¹äºæ˜æ˜¾ä¸å¯èƒ½æ›´ä¼˜çš„çŠ¶æ€æå‰å‰ªæ

ï¼ˆ3ï¼‰å¹¶è¡ŒåŒ–ï¼šä¸åŒé¢„ç®—çš„è®¡ç®—å¯ä»¥å¹¶è¡Œå¤„ç†

ï¼ˆ4ï¼‰å¯å‘å¼åˆå§‹åŒ–ï¼šå…ˆç”¨è´ªå¿ƒå¾—åˆ°ä¸Šç•Œï¼ŒåŠ é€ŸDPæ”¶æ•›



4.3 å¯¹åŠ¨æ€è§„åˆ’çš„ç†è§£æ·±åŒ–

é€šè¿‡è¿™ä¸ªé¡¹ç›®ï¼Œæˆ‘å¯¹åŠ¨æ€è§„åˆ’æœ‰äº†æ›´æ·±å…¥çš„ç†è§£ï¼š

ï¼ˆ1ï¼‰DPä¸ä»…æ˜¯ç®—æ³•ï¼Œæ›´æ˜¯ä¸€ç§æ€ç»´æ–¹å¼ï¼šå°†å¤æ‚é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜

ï¼ˆ2ï¼‰çŠ¶æ€è®¾è®¡éœ€è¦å¹³è¡¡ï¼šçŠ¶æ€å¤ªå°‘æ— æ³•è¡¨è¾¾é—®é¢˜ï¼ŒçŠ¶æ€å¤ªå¤šä¼šçˆ†ç‚¸

ï¼ˆ3ï¼‰è½¬ç§»æ–¹ç¨‹è¦å‡†ç¡®ï¼šå¿…é¡»è¦†ç›–æ‰€æœ‰å¯èƒ½çš„å†³ç­–

ï¼ˆ4ï¼‰å›æº¯æ˜¯DPçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼šä¸ä»…è¦ç®—å‡ºæœ€ä¼˜å€¼ï¼Œè¿˜è¦çŸ¥é“å¦‚ä½•è¾¾åˆ°



4.4 æ€»ç»“

&#x20;      æœ¬æ¬¡å®éªŒè®©æˆ‘å…¨é¢æŒæ¡äº†åŠ¨æ€è§„åˆ’åœ¨åº“å­˜ä¼˜åŒ–ä¸­çš„åº”ç”¨ã€‚ä»é—®é¢˜å»ºæ¨¡åˆ°ç®—æ³•å®ç°ï¼Œä»ç†è®ºåˆ†æåˆ°å®éªŒéªŒè¯ï¼Œæ¯ä¸ªç¯èŠ‚éƒ½åŠ æ·±äº†æˆ‘å¯¹ç®—æ³•çš„ç†è§£ã€‚ç‰¹åˆ«æ˜¯é€šè¿‡ä¸åŒé¢„ç®—çš„å¯¹æ¯”å®éªŒï¼Œæˆ‘çœ‹åˆ°äº†ç®—æ³•åœ¨å®é™…åœºæ™¯ä¸­çš„è¡¨ç°ï¼Œè¿™å¯¹æœªæ¥çš„å­¦ä¹ å’Œå·¥ä½œéƒ½æœ‰å¾ˆå¤§å¸®åŠ©ã€‚åŒæ—¶ï¼Œæˆ‘ä¹Ÿè®¤è¯†åˆ°ç®—æ³•å®ç°ä¸ä»…è¦æ­£ç¡®ï¼Œè¿˜è¦è€ƒè™‘æ•ˆç‡ã€å¯è¯»æ€§å’Œç”¨æˆ·ä½“éªŒã€‚è¿™äº›éƒ½æ˜¯ä¼˜ç§€ç¨‹åºå‘˜éœ€è¦å…·å¤‡çš„ç´ è´¨ã€‚æœ€åï¼Œæ„Ÿè°¢è¿™æ¬¡å®éªŒæœºä¼šï¼Œè®©æˆ‘èƒ½å¤Ÿå°†ç†è®ºçŸ¥è¯†è½¬åŒ–ä¸ºå®é™…èƒ½åŠ›ï¼Œä¸ºä»Šåçš„å­¦ä¹ å’Œç ”ç©¶æ‰“ä¸‹åšå®åŸºç¡€ã€‚



**æˆæœå±•ç¤º**

**ä¸€ã€ ç³»ç»Ÿè®¾è®¡**

**2.ç®—æ³•è®¾è®¡æ€æƒ³**

ã€é—®é¢˜åˆ†æã€‘

åº“å­˜ä¼˜åŒ–é—®é¢˜æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªå¸¦çº¦æŸçš„å¤šé˜¶æ®µå†³ç­–é—®é¢˜ï¼š

* æ¯ä¸ªç‰©å“æ˜¯ä¸€ä¸ªå†³ç­–é˜¶æ®µ

* æ¯ä¸ªé˜¶æ®µæœ‰å¤šç§å†³ç­–é€‰æ‹©ï¼ˆä¸è¡¥è´§æˆ–é€‰æ‹©æŸä¸ªè¡¥è´§æ–¹æ¡ˆï¼‰

* å†³ç­–å—åˆ°æ€»é¢„ç®—çš„çº¦æŸ

* ç›®æ ‡æ˜¯ä½¿æ€»ç¼ºè´§ç½šé‡‘æœ€å°

ã€è®¾è®¡æ€è·¯ã€‘

é‡‡ç”¨åŠ¨æ€è§„åˆ’ï¼ˆDynamic Programmingï¼‰æ–¹æ³•ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯ï¼š

ï¼ˆ1ï¼‰å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜

* åŸé—®é¢˜ï¼šnä¸ªç‰©å“ï¼Œé¢„ç®—Bï¼Œæœ€å°ç½šé‡‘

* å­é—®é¢˜ï¼šå‰iä¸ªç‰©å“ï¼Œé¢„ç®—bï¼Œæœ€å°ç½šé‡‘ï¼ˆiâ‰¤n, bâ‰¤Bï¼‰

ï¼ˆ2ï¼‰å»ºç«‹çŠ¶æ€è½¬ç§»å…³ç³»

* çŠ¶æ€ï¼šdp\[i]\[b] = å¤„ç†å‰iä¸ªç‰©å“ï¼Œé¢„ç®—bä¸‹çš„æœ€å°ç½šé‡‘

* è½¬ç§»ï¼šå½“å‰çŠ¶æ€ç”±å‰ä¸€ä¸ªçŠ¶æ€å’Œå½“å‰å†³ç­–å†³å®š

* å†³ç­–ï¼šå¯¹ç‰©å“iï¼Œé€‰æ‹©ä¸è¡¥è´§æˆ–æŸä¸ªè¡¥è´§æ–¹æ¡ˆ

ï¼ˆ3ï¼‰åˆ©ç”¨æœ€ä¼˜å­ç»“æ„æ€§è´¨

* å¦‚æœdp\[i]\[b]æ˜¯æœ€ä¼˜çš„ï¼Œé‚£ä¹ˆdp\[i-1]\[b']ï¼ˆb'â‰¤bï¼‰ä¹Ÿå¿…ç„¶æ˜¯æœ€ä¼˜çš„

* å½“å‰æœ€ä¼˜å†³ç­– = å‰ä¸€ä¸ªæœ€ä¼˜çŠ¶æ€ + å½“å‰æœ€ä¼˜é€‰æ‹©

ï¼ˆ4ï¼‰è‡ªåº•å‘ä¸Šå¡«è¡¨

* ä»dp\[0]\[0]å¼€å§‹ï¼Œé€æ­¥è®¡ç®—dp\[1]\[\*], dp\[2]\[\*], ..., dp\[n]\[\*]

* æ¯ä¸ªçŠ¶æ€è€ƒè™‘æ‰€æœ‰å¯èƒ½çš„å†³ç­–ï¼Œé€‰æ‹©æœ€ä¼˜çš„

ï¼ˆ5ï¼‰å›æº¯æ„é€ è§£

* ä½¿ç”¨choiceè¡¨è®°å½•æ¯ä¸ªçŠ¶æ€çš„æœ€ä¼˜é€‰æ‹©

* ä»æœ€ç»ˆçŠ¶æ€å›æº¯ï¼Œå¾—åˆ°å®Œæ•´çš„è¡¥è´§æ–¹æ¡ˆ

ã€è®¾è®¡è¦ç‚¹ã€‘

ï¼ˆ1ï¼‰çŠ¶æ€è®¾è®¡ï¼šé€‰æ‹©"å‰iä¸ªç‰©å“ï¼Œé¢„ç®—b"ä½œä¸ºçŠ¶æ€ï¼Œæ—¢ç®€æ´åˆå®Œæ•´

ï¼ˆ2ï¼‰è½¬ç§»è®¾è®¡ï¼šè€ƒè™‘æ‰€æœ‰å¯èƒ½çš„å†³ç­–ï¼ˆä¸è¡¥è´§+æ‰€æœ‰è¡¥è´§æ–¹æ¡ˆï¼‰

ï¼ˆ3ï¼‰è¾¹ç•Œå¤„ç†ï¼šdp\[0]\[0]=0ï¼Œå…¶ä»–åˆå§‹åŒ–ä¸ºæ— ç©·å¤§ï¼Œç¡®ä¿åˆæ³•æ€§

ï¼ˆ4ï¼‰å›æº¯è®¾è®¡ï¼šä½¿ç”¨choiceè¡¨è®°å½•é€‰æ‹©ï¼Œä¾¿äºæ„é€ æœ€ä¼˜æ–¹æ¡ˆ



**3.æ•°æ®ç»“æ„**

ã€2.2.1 è¡¥è´§æ–¹æ¡ˆç»“æ„ä½“ã€‘

```c++
struct InventoryOption {
    int qty;   // è¡¥è´§æ•°é‡ï¼ˆquantityï¼‰
    int cost;  // è¡¥è´§æˆæœ¬ï¼ˆcostï¼‰
};
```

ã€2.2.2 åº“å­˜ç‰©å“ç»“æ„ä½“ã€‘

```c++
struct InventoryItem {
    string name;                    // ç‰©å“åç§°
    int onHand;                     // ç°æœ‰åº“å­˜é‡ï¼ˆon-hand inventoryï¼‰
    int demand;                     // éœ€æ±‚é‡
    int unitPenalty;                // å•ä½ç¼ºè´§ç½šé‡‘
    vector<InventoryOption> options; // å¯é€‰è¡¥è´§æ–¹æ¡ˆåˆ—è¡¨
};
```

ã€2.2.3 åŠ¨æ€è§„åˆ’çŠ¶æ€è¡¨ã€‘

```c++
vector<vector<long long>> dp(n+1, vector<long long>(budget+1, INF));
```



**4.ç®—æ³•æµç¨‹å›¾**

4.1 åº“å­˜ä¼˜åŒ–æ¨¡å‹è®¾è®¡æµç¨‹å›¾

![](images/image-1.png)

4.2 åŠ¨æ€è§„åˆ’ç®—æ³•å®ç°ï¼ˆåº“å­˜ä¼˜åŒ–ï¼‰æµç¨‹å›¾

![](<images/mermaid-20251215 013523.png>)



4.3 å›æº¯æ–¹æ¡ˆæ±‚è§£ï¼ˆTSP åˆ†æ”¯é™ç•Œï¼‰æµç¨‹å›¾

![](images/3.png)



# é¡¹ç›®æˆªå›¾

![](images/image-2.png)

![](images/image-3.png)

![](images/image-10.png)

![](images/image-8.png)

![](images/image-7.png)

![](images/image-6.png)

![](images/image-4.png)

![](images/image-5.png)

![](images/image-13.png)

